import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toESM
} from "./chunk-J32WSRGE.js";

// node_modules/promise-limit/index.js
var require_promise_limit = __commonJS({
  "node_modules/promise-limit/index.js"(exports, module) {
    function limiter(count) {
      var outstanding = 0;
      var jobs = [];
      function remove() {
        outstanding--;
        if (outstanding < count) {
          dequeue();
        }
      }
      function dequeue() {
        var job = jobs.shift();
        semaphore.queue = jobs.length;
        if (job) {
          run(job.fn).then(job.resolve).catch(job.reject);
        }
      }
      function queue(fn) {
        return new Promise(function(resolve, reject) {
          jobs.push({ fn, resolve, reject });
          semaphore.queue = jobs.length;
        });
      }
      function run(fn) {
        outstanding++;
        try {
          return Promise.resolve(fn()).then(function(result) {
            remove();
            return result;
          }, function(error) {
            remove();
            throw error;
          });
        } catch (err) {
          remove();
          return Promise.reject(err);
        }
      }
      var semaphore = function(fn) {
        if (outstanding >= count) {
          return queue(fn);
        } else {
          return run(fn);
        }
      };
      return semaphore;
    }
    function map(items, mapper) {
      var failed = false;
      var limit = this;
      return Promise.all(items.map(function() {
        var args = arguments;
        return limit(function() {
          if (!failed) {
            return mapper.apply(void 0, args).catch(function(e) {
              failed = true;
              throw e;
            });
          }
        });
      }));
    }
    function addExtras(fn) {
      fn.queue = 0;
      fn.map = map;
      return fn;
    }
    module.exports = function(count) {
      if (count) {
        return addExtras(limiter(count));
      } else {
        return addExtras(function(fn) {
          return fn();
        });
      }
    };
  }
});

// node_modules/@libsql/core/lib-esm/api.js
var LibsqlError = class extends Error {
  constructor(message, code, rawCode, cause) {
    if (code !== void 0) {
      message = `${code}: ${message}`;
    }
    super(message, { cause });
    /** Machine-readable error code. */
    __publicField(this, "code");
    /** Raw numeric error code */
    __publicField(this, "rawCode");
    this.code = code;
    this.rawCode = rawCode;
    this.name = "LibsqlError";
  }
};

// node_modules/@libsql/core/lib-esm/uri.js
function parseUri(text) {
  const match = URI_RE.exec(text);
  if (match === null) {
    throw new LibsqlError(`The URL '${text}' is not in a valid format`, "URL_INVALID");
  }
  const groups = match.groups;
  const scheme = groups["scheme"];
  const authority = groups["authority"] !== void 0 ? parseAuthority(groups["authority"]) : void 0;
  const path = percentDecode(groups["path"]);
  const query = groups["query"] !== void 0 ? parseQuery(groups["query"]) : void 0;
  const fragment = groups["fragment"] !== void 0 ? percentDecode(groups["fragment"]) : void 0;
  return { scheme, authority, path, query, fragment };
}
var URI_RE = (() => {
  const SCHEME = "(?<scheme>[A-Za-z][A-Za-z.+-]*)";
  const AUTHORITY = "(?<authority>[^/?#]*)";
  const PATH = "(?<path>[^?#]*)";
  const QUERY = "(?<query>[^#]*)";
  const FRAGMENT = "(?<fragment>.*)";
  return new RegExp(`^${SCHEME}:(//${AUTHORITY})?${PATH}(\\?${QUERY})?(#${FRAGMENT})?$`, "su");
})();
function parseAuthority(text) {
  const match = AUTHORITY_RE.exec(text);
  if (match === null) {
    throw new LibsqlError("The authority part of the URL is not in a valid format", "URL_INVALID");
  }
  const groups = match.groups;
  const host = percentDecode(groups["host_br"] ?? groups["host"]);
  const port = groups["port"] ? parseInt(groups["port"], 10) : void 0;
  const userinfo = groups["username"] !== void 0 ? {
    username: percentDecode(groups["username"]),
    password: groups["password"] !== void 0 ? percentDecode(groups["password"]) : void 0
  } : void 0;
  return { host, port, userinfo };
}
var AUTHORITY_RE = (() => {
  return new RegExp(`^((?<username>[^:]*)(:(?<password>.*))?@)?((?<host>[^:\\[\\]]*)|(\\[(?<host_br>[^\\[\\]]*)\\]))(:(?<port>[0-9]*))?$`, "su");
})();
function parseQuery(text) {
  const sequences = text.split("&");
  const pairs = [];
  for (const sequence of sequences) {
    if (sequence === "") {
      continue;
    }
    let key;
    let value;
    const splitIdx = sequence.indexOf("=");
    if (splitIdx < 0) {
      key = sequence;
      value = "";
    } else {
      key = sequence.substring(0, splitIdx);
      value = sequence.substring(splitIdx + 1);
    }
    pairs.push({
      key: percentDecode(key.replaceAll("+", " ")),
      value: percentDecode(value.replaceAll("+", " "))
    });
  }
  return { pairs };
}
function percentDecode(text) {
  try {
    return decodeURIComponent(text);
  } catch (e) {
    if (e instanceof URIError) {
      throw new LibsqlError(`URL component has invalid percent encoding: ${e}`, "URL_INVALID", void 0, e);
    }
    throw e;
  }
}
function encodeBaseUrl(scheme, authority, path) {
  if (authority === void 0) {
    throw new LibsqlError(`URL with scheme ${JSON.stringify(scheme + ":")} requires authority (the "//" part)`, "URL_INVALID");
  }
  const schemeText = `${scheme}:`;
  const hostText = encodeHost(authority.host);
  const portText = encodePort(authority.port);
  const userinfoText = encodeUserinfo(authority.userinfo);
  const authorityText = `//${userinfoText}${hostText}${portText}`;
  let pathText = path.split("/").map(encodeURIComponent).join("/");
  if (pathText !== "" && !pathText.startsWith("/")) {
    pathText = "/" + pathText;
  }
  return new URL(`${schemeText}${authorityText}${pathText}`);
}
function encodeHost(host) {
  return host.includes(":") ? `[${encodeURI(host)}]` : encodeURI(host);
}
function encodePort(port) {
  return port !== void 0 ? `:${port}` : "";
}
function encodeUserinfo(userinfo) {
  if (userinfo === void 0) {
    return "";
  }
  const usernameText = encodeURIComponent(userinfo.username);
  const passwordText = userinfo.password !== void 0 ? `:${encodeURIComponent(userinfo.password)}` : "";
  return `${usernameText}${passwordText}@`;
}

// node_modules/js-base64/base64.mjs
var version = "3.7.7";
var VERSION = version;
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = (u) => u.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
var encodeURI2 = (src) => encode(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = (b) => b.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a).split("").map((c) => c.charCodeAt(0)));
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));
var isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
var extendString = function() {
  const _add2 = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add2("fromBase64", function() {
    return decode(this);
  });
  _add2("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add2("toBase64URI", function() {
    return encode(this, true);
  });
  _add2("toBase64URL", function() {
    return encode(this, true);
  });
  _add2("toUint8Array", function() {
    return toUint8Array(this);
  });
};
var extendUint8Array = function() {
  const _add2 = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add2("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add2("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add2("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
var extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
var gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI: encodeURI2,
  encodeURL: encodeURI2,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};

// node_modules/@libsql/core/lib-esm/util.js
var supportedUrlLink = "https://github.com/libsql/libsql-client-ts#supported-urls";
function transactionModeToBegin(mode) {
  if (mode === "write") {
    return "BEGIN IMMEDIATE";
  } else if (mode === "read") {
    return "BEGIN TRANSACTION READONLY";
  } else if (mode === "deferred") {
    return "BEGIN DEFERRED";
  } else {
    throw RangeError('Unknown transaction mode, supported values are "write", "read" and "deferred"');
  }
}
var ResultSetImpl = class {
  constructor(columns, columnTypes, rows, rowsAffected, lastInsertRowid) {
    __publicField(this, "columns");
    __publicField(this, "columnTypes");
    __publicField(this, "rows");
    __publicField(this, "rowsAffected");
    __publicField(this, "lastInsertRowid");
    this.columns = columns;
    this.columnTypes = columnTypes;
    this.rows = rows;
    this.rowsAffected = rowsAffected;
    this.lastInsertRowid = lastInsertRowid;
  }
  toJSON() {
    return {
      columns: this.columns,
      columnTypes: this.columnTypes,
      rows: this.rows.map(rowToJson),
      rowsAffected: this.rowsAffected,
      lastInsertRowid: this.lastInsertRowid !== void 0 ? "" + this.lastInsertRowid : null
    };
  }
};
function rowToJson(row) {
  return Array.prototype.map.call(row, valueToJson);
}
function valueToJson(value) {
  if (typeof value === "bigint") {
    return "" + value;
  } else if (value instanceof ArrayBuffer) {
    return gBase64.fromUint8Array(new Uint8Array(value));
  } else {
    return value;
  }
}

// node_modules/@libsql/core/lib-esm/config.js
var inMemoryMode = ":memory:";
function expandConfig(config, preferHttp) {
  var _a, _b;
  if (typeof config !== "object") {
    throw new TypeError(`Expected client configuration as object, got ${typeof config}`);
  }
  let { url, authToken, tls, intMode, concurrency } = config;
  concurrency = Math.max(0, concurrency || 20);
  intMode ?? (intMode = "number");
  let connectionQueryParams = [];
  if (url === inMemoryMode) {
    url = "file::memory:";
  }
  const uri = parseUri(url);
  const originalUriScheme = uri.scheme.toLowerCase();
  const isInMemoryMode = originalUriScheme === "file" && uri.path === inMemoryMode && uri.authority === void 0;
  let queryParamsDef;
  if (isInMemoryMode) {
    queryParamsDef = {
      cache: {
        values: ["shared", "private"],
        update: (key, value) => connectionQueryParams.push(`${key}=${value}`)
      }
    };
  } else {
    queryParamsDef = {
      tls: {
        values: ["0", "1"],
        update: (_, value) => tls = value === "1"
      },
      authToken: {
        update: (_, value) => authToken = value
      }
    };
  }
  for (const { key, value } of ((_a = uri.query) == null ? void 0 : _a.pairs) ?? []) {
    if (!Object.hasOwn(queryParamsDef, key)) {
      throw new LibsqlError(`Unsupported URL query parameter ${JSON.stringify(key)}`, "URL_PARAM_NOT_SUPPORTED");
    }
    const queryParamDef = queryParamsDef[key];
    if (queryParamDef.values !== void 0 && !queryParamDef.values.includes(value)) {
      throw new LibsqlError(`Unknown value for the "${key}" query argument: ${JSON.stringify(value)}. Supported values are: [${queryParamDef.values.map((x) => '"' + x + '"').join(", ")}]`, "URL_INVALID");
    }
    if (queryParamDef.update !== void 0) {
      queryParamDef == null ? void 0 : queryParamDef.update(key, value);
    }
  }
  const connectionQueryParamsString = connectionQueryParams.length === 0 ? "" : `?${connectionQueryParams.join("&")}`;
  const path = uri.path + connectionQueryParamsString;
  let scheme;
  if (originalUriScheme === "libsql") {
    if (tls === false) {
      if (((_b = uri.authority) == null ? void 0 : _b.port) === void 0) {
        throw new LibsqlError('A "libsql:" URL with ?tls=0 must specify an explicit port', "URL_INVALID");
      }
      scheme = preferHttp ? "http" : "ws";
    } else {
      scheme = preferHttp ? "https" : "wss";
    }
  } else {
    scheme = originalUriScheme;
  }
  if (scheme === "http" || scheme === "ws") {
    tls ?? (tls = false);
  } else {
    tls ?? (tls = true);
  }
  if (scheme !== "http" && scheme !== "ws" && scheme !== "https" && scheme !== "wss" && scheme !== "file") {
    throw new LibsqlError(`The client supports only "libsql:", "wss:", "ws:", "https:", "http:" and "file:" URLs, got ${JSON.stringify(uri.scheme + ":")}. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  if (intMode !== "number" && intMode !== "bigint" && intMode !== "string") {
    throw new TypeError(`Invalid value for intMode, expected "number", "bigint" or "string", got ${JSON.stringify(intMode)}`);
  }
  if (uri.fragment !== void 0) {
    throw new LibsqlError(`URL fragments are not supported: ${JSON.stringify("#" + uri.fragment)}`, "URL_INVALID");
  }
  if (isInMemoryMode) {
    return {
      scheme: "file",
      tls: false,
      path,
      intMode,
      concurrency,
      syncUrl: config.syncUrl,
      syncInterval: config.syncInterval,
      readYourWrites: config.readYourWrites,
      offline: config.offline,
      fetch: config.fetch,
      authToken: void 0,
      encryptionKey: void 0,
      authority: void 0
    };
  }
  return {
    scheme,
    tls,
    authority: uri.authority,
    path,
    authToken,
    intMode,
    concurrency,
    encryptionKey: config.encryptionKey,
    syncUrl: config.syncUrl,
    syncInterval: config.syncInterval,
    readYourWrites: config.readYourWrites,
    offline: config.offline,
    fetch: config.fetch
  };
}

// node_modules/@libsql/isomorphic-ws/web.mjs
var _WebSocket;
if (typeof WebSocket !== "undefined") {
  _WebSocket = WebSocket;
} else if (typeof global !== "undefined") {
  _WebSocket = global.WebSocket;
} else if (typeof window !== "undefined") {
  _WebSocket = window.WebSocket;
} else if (typeof self !== "undefined") {
  _WebSocket = self.WebSocket;
}

// node_modules/@libsql/hrana-client/lib-esm/client.js
var Client = class {
  /** @private */
  constructor() {
    /** Representation of integers returned from the database. See {@link IntMode}.
     *
     * This value is inherited by {@link Stream} objects created with {@link openStream}, but you can
     * override the integer mode for every stream by setting {@link Stream.intMode} on the stream.
     */
    __publicField(this, "intMode");
    this.intMode = "number";
  }
};

// node_modules/@libsql/hrana-client/lib-esm/errors.js
var ClientError = class extends Error {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "ClientError";
  }
};
var ProtoError = class extends ClientError {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "ProtoError";
  }
};
var ResponseError = class extends ClientError {
  /** @private */
  constructor(message, protoError) {
    super(message);
    __publicField(this, "code");
    /** @internal */
    __publicField(this, "proto");
    this.name = "ResponseError";
    this.code = protoError.code;
    this.proto = protoError;
    this.stack = void 0;
  }
};
var ClosedError = class extends ClientError {
  /** @private */
  constructor(message, cause) {
    if (cause !== void 0) {
      super(`${message}: ${cause}`);
      this.cause = cause;
    } else {
      super(message);
    }
    this.name = "ClosedError";
  }
};
var WebSocketUnsupportedError = class extends ClientError {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "WebSocketUnsupportedError";
  }
};
var WebSocketError = class extends ClientError {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "WebSocketError";
  }
};
var HttpServerError = class extends ClientError {
  /** @private */
  constructor(message, status) {
    super(message);
    __publicField(this, "status");
    this.status = status;
    this.name = "HttpServerError";
  }
};
var ProtocolVersionError = class extends ClientError {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "ProtocolVersionError";
  }
};
var InternalError = class extends ClientError {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "InternalError";
  }
};
var MisuseError = class extends ClientError {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "MisuseError";
  }
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/json/decode.js
function string(value) {
  if (typeof value === "string") {
    return value;
  }
  throw typeError(value, "string");
}
function stringOpt(value) {
  if (value === null || value === void 0) {
    return void 0;
  } else if (typeof value === "string") {
    return value;
  }
  throw typeError(value, "string or null");
}
function number(value) {
  if (typeof value === "number") {
    return value;
  }
  throw typeError(value, "number");
}
function boolean(value) {
  if (typeof value === "boolean") {
    return value;
  }
  throw typeError(value, "boolean");
}
function array(value) {
  if (Array.isArray(value)) {
    return value;
  }
  throw typeError(value, "array");
}
function object(value) {
  if (value !== null && typeof value === "object" && !Array.isArray(value)) {
    return value;
  }
  throw typeError(value, "object");
}
function arrayObjectsMap(value, fun) {
  return array(value).map((elemValue) => fun(object(elemValue)));
}
function typeError(value, expected) {
  if (value === void 0) {
    return new ProtoError(`Expected ${expected}, but the property was missing`);
  }
  let received = typeof value;
  if (value === null) {
    received = "null";
  } else if (Array.isArray(value)) {
    received = "array";
  }
  return new ProtoError(`Expected ${expected}, received ${received}`);
}
function readJsonObject(value, fun) {
  return fun(object(value));
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/json/encode.js
var _output, _isFirst, _key, key_fn;
var ObjectWriter = class {
  constructor(output) {
    __privateAdd(this, _key);
    __privateAdd(this, _output, void 0);
    __privateAdd(this, _isFirst, void 0);
    __privateSet(this, _output, output);
    __privateSet(this, _isFirst, false);
  }
  begin() {
    __privateGet(this, _output).push("{");
    __privateSet(this, _isFirst, true);
  }
  end() {
    __privateGet(this, _output).push("}");
    __privateSet(this, _isFirst, false);
  }
  string(name, value) {
    __privateMethod(this, _key, key_fn).call(this, name);
    __privateGet(this, _output).push(JSON.stringify(value));
  }
  stringRaw(name, value) {
    __privateMethod(this, _key, key_fn).call(this, name);
    __privateGet(this, _output).push('"');
    __privateGet(this, _output).push(value);
    __privateGet(this, _output).push('"');
  }
  number(name, value) {
    __privateMethod(this, _key, key_fn).call(this, name);
    __privateGet(this, _output).push("" + value);
  }
  boolean(name, value) {
    __privateMethod(this, _key, key_fn).call(this, name);
    __privateGet(this, _output).push(value ? "true" : "false");
  }
  object(name, value, valueFun) {
    __privateMethod(this, _key, key_fn).call(this, name);
    this.begin();
    valueFun(this, value);
    this.end();
  }
  arrayObjects(name, values, valueFun) {
    __privateMethod(this, _key, key_fn).call(this, name);
    __privateGet(this, _output).push("[");
    for (let i = 0; i < values.length; ++i) {
      if (i !== 0) {
        __privateGet(this, _output).push(",");
      }
      this.begin();
      valueFun(this, values[i]);
      this.end();
    }
    __privateGet(this, _output).push("]");
  }
};
_output = new WeakMap();
_isFirst = new WeakMap();
_key = new WeakSet();
key_fn = function(name) {
  if (__privateGet(this, _isFirst)) {
    __privateGet(this, _output).push('"');
    __privateSet(this, _isFirst, false);
  } else {
    __privateGet(this, _output).push(',"');
  }
  __privateGet(this, _output).push(name);
  __privateGet(this, _output).push('":');
};
function writeJsonObject(value, fun) {
  const output = [];
  const writer = new ObjectWriter(output);
  writer.begin();
  fun(writer, value);
  writer.end();
  return output.join("");
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.js
var VARINT = 0;
var FIXED_64 = 1;
var LENGTH_DELIMITED = 2;
var FIXED_32 = 5;

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/decode.js
var _array, _view, _pos;
var MessageReader = class {
  constructor(array2) {
    __privateAdd(this, _array, void 0);
    __privateAdd(this, _view, void 0);
    __privateAdd(this, _pos, void 0);
    __privateSet(this, _array, array2);
    __privateSet(this, _view, new DataView(array2.buffer, array2.byteOffset, array2.byteLength));
    __privateSet(this, _pos, 0);
  }
  varint() {
    let value = 0;
    for (let shift = 0; ; shift += 7) {
      const byte = __privateGet(this, _array)[__privateWrapper(this, _pos)._++];
      value |= (byte & 127) << shift;
      if (!(byte & 128)) {
        break;
      }
    }
    return value;
  }
  varintBig() {
    let value = 0n;
    for (let shift = 0n; ; shift += 7n) {
      const byte = __privateGet(this, _array)[__privateWrapper(this, _pos)._++];
      value |= BigInt(byte & 127) << shift;
      if (!(byte & 128)) {
        break;
      }
    }
    return value;
  }
  bytes(length) {
    const array2 = new Uint8Array(__privateGet(this, _array).buffer, __privateGet(this, _array).byteOffset + __privateGet(this, _pos), length);
    __privateSet(this, _pos, __privateGet(this, _pos) + length);
    return array2;
  }
  double() {
    const value = __privateGet(this, _view).getFloat64(__privateGet(this, _pos), true);
    __privateSet(this, _pos, __privateGet(this, _pos) + 8);
    return value;
  }
  skipVarint() {
    for (; ; ) {
      const byte = __privateGet(this, _array)[__privateWrapper(this, _pos)._++];
      if (!(byte & 128)) {
        break;
      }
    }
  }
  skip(count) {
    __privateSet(this, _pos, __privateGet(this, _pos) + count);
  }
  eof() {
    return __privateGet(this, _pos) >= __privateGet(this, _array).byteLength;
  }
};
_array = new WeakMap();
_view = new WeakMap();
_pos = new WeakMap();
var _reader, _wireType, _expect, expect_fn;
var FieldReader = class {
  constructor(reader) {
    __privateAdd(this, _expect);
    __privateAdd(this, _reader, void 0);
    __privateAdd(this, _wireType, void 0);
    __privateSet(this, _reader, reader);
    __privateSet(this, _wireType, -1);
  }
  setup(wireType) {
    __privateSet(this, _wireType, wireType);
  }
  bytes() {
    __privateMethod(this, _expect, expect_fn).call(this, LENGTH_DELIMITED);
    const length = __privateGet(this, _reader).varint();
    return __privateGet(this, _reader).bytes(length);
  }
  string() {
    return new TextDecoder().decode(this.bytes());
  }
  message(def) {
    return readProtobufMessage(this.bytes(), def);
  }
  int32() {
    __privateMethod(this, _expect, expect_fn).call(this, VARINT);
    return __privateGet(this, _reader).varint();
  }
  uint32() {
    return this.int32();
  }
  bool() {
    return this.int32() !== 0;
  }
  uint64() {
    __privateMethod(this, _expect, expect_fn).call(this, VARINT);
    return __privateGet(this, _reader).varintBig();
  }
  sint64() {
    const value = this.uint64();
    return value >> 1n ^ -(value & 1n);
  }
  double() {
    __privateMethod(this, _expect, expect_fn).call(this, FIXED_64);
    return __privateGet(this, _reader).double();
  }
  maybeSkip() {
    if (__privateGet(this, _wireType) < 0) {
      return;
    } else if (__privateGet(this, _wireType) === VARINT) {
      __privateGet(this, _reader).skipVarint();
    } else if (__privateGet(this, _wireType) === FIXED_64) {
      __privateGet(this, _reader).skip(8);
    } else if (__privateGet(this, _wireType) === LENGTH_DELIMITED) {
      const length = __privateGet(this, _reader).varint();
      __privateGet(this, _reader).skip(length);
    } else if (__privateGet(this, _wireType) === FIXED_32) {
      __privateGet(this, _reader).skip(4);
    } else {
      throw new ProtoError(`Unexpected wire type ${__privateGet(this, _wireType)}`);
    }
    __privateSet(this, _wireType, -1);
  }
};
_reader = new WeakMap();
_wireType = new WeakMap();
_expect = new WeakSet();
expect_fn = function(expectedWireType) {
  if (__privateGet(this, _wireType) !== expectedWireType) {
    throw new ProtoError(`Expected wire type ${expectedWireType}, got ${__privateGet(this, _wireType)}`);
  }
  __privateSet(this, _wireType, -1);
};
function readProtobufMessage(data, def) {
  const msgReader = new MessageReader(data);
  const fieldReader = new FieldReader(msgReader);
  let value = def.default();
  while (!msgReader.eof()) {
    const key = msgReader.varint();
    const tag = key >> 3;
    const wireType = key & 7;
    fieldReader.setup(wireType);
    const tagFun = def[tag];
    if (tagFun !== void 0) {
      const returnedValue = tagFun(fieldReader, value);
      if (returnedValue !== void 0) {
        value = returnedValue;
      }
    }
    fieldReader.maybeSkip();
  }
  return value;
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/encode.js
var _buf, _array2, _view2, _pos2, _ensure, ensure_fn, _varint, varint_fn, _varintBig, varintBig_fn, _tag, tag_fn;
var _MessageWriter = class _MessageWriter {
  constructor() {
    __privateAdd(this, _ensure);
    __privateAdd(this, _varint);
    __privateAdd(this, _varintBig);
    __privateAdd(this, _tag);
    __privateAdd(this, _buf, void 0);
    __privateAdd(this, _array2, void 0);
    __privateAdd(this, _view2, void 0);
    __privateAdd(this, _pos2, void 0);
    __privateSet(this, _buf, new ArrayBuffer(256));
    __privateSet(this, _array2, new Uint8Array(__privateGet(this, _buf)));
    __privateSet(this, _view2, new DataView(__privateGet(this, _buf)));
    __privateSet(this, _pos2, 0);
  }
  bytes(tag, value) {
    __privateMethod(this, _tag, tag_fn).call(this, tag, LENGTH_DELIMITED);
    __privateMethod(this, _varint, varint_fn).call(this, value.byteLength);
    __privateMethod(this, _ensure, ensure_fn).call(this, value.byteLength);
    __privateGet(this, _array2).set(value, __privateGet(this, _pos2));
    __privateSet(this, _pos2, __privateGet(this, _pos2) + value.byteLength);
  }
  string(tag, value) {
    this.bytes(tag, new TextEncoder().encode(value));
  }
  message(tag, value, fun) {
    const writer = new _MessageWriter();
    fun(writer, value);
    this.bytes(tag, writer.data());
  }
  int32(tag, value) {
    __privateMethod(this, _tag, tag_fn).call(this, tag, VARINT);
    __privateMethod(this, _varint, varint_fn).call(this, value);
  }
  uint32(tag, value) {
    this.int32(tag, value);
  }
  bool(tag, value) {
    this.int32(tag, value ? 1 : 0);
  }
  sint64(tag, value) {
    __privateMethod(this, _tag, tag_fn).call(this, tag, VARINT);
    __privateMethod(this, _varintBig, varintBig_fn).call(this, value << 1n ^ value >> 63n);
  }
  double(tag, value) {
    __privateMethod(this, _tag, tag_fn).call(this, tag, FIXED_64);
    __privateMethod(this, _ensure, ensure_fn).call(this, 8);
    __privateGet(this, _view2).setFloat64(__privateGet(this, _pos2), value, true);
    __privateSet(this, _pos2, __privateGet(this, _pos2) + 8);
  }
  data() {
    return new Uint8Array(__privateGet(this, _buf), 0, __privateGet(this, _pos2));
  }
};
_buf = new WeakMap();
_array2 = new WeakMap();
_view2 = new WeakMap();
_pos2 = new WeakMap();
_ensure = new WeakSet();
ensure_fn = function(extra) {
  if (__privateGet(this, _pos2) + extra <= __privateGet(this, _buf).byteLength) {
    return;
  }
  let newCap = __privateGet(this, _buf).byteLength;
  while (newCap < __privateGet(this, _pos2) + extra) {
    newCap *= 2;
  }
  const newBuf = new ArrayBuffer(newCap);
  const newArray = new Uint8Array(newBuf);
  const newView = new DataView(newBuf);
  newArray.set(new Uint8Array(__privateGet(this, _buf), 0, __privateGet(this, _pos2)));
  __privateSet(this, _buf, newBuf);
  __privateSet(this, _array2, newArray);
  __privateSet(this, _view2, newView);
};
_varint = new WeakSet();
varint_fn = function(value) {
  __privateMethod(this, _ensure, ensure_fn).call(this, 5);
  value = 0 | value;
  do {
    let byte = value & 127;
    value >>>= 7;
    byte |= value ? 128 : 0;
    __privateGet(this, _array2)[__privateWrapper(this, _pos2)._++] = byte;
  } while (value);
};
_varintBig = new WeakSet();
varintBig_fn = function(value) {
  __privateMethod(this, _ensure, ensure_fn).call(this, 10);
  value = value & 0xffffffffffffffffn;
  do {
    let byte = Number(value & 0x7fn);
    value >>= 7n;
    byte |= value ? 128 : 0;
    __privateGet(this, _array2)[__privateWrapper(this, _pos2)._++] = byte;
  } while (value);
};
_tag = new WeakSet();
tag_fn = function(tag, wireType) {
  __privateMethod(this, _varint, varint_fn).call(this, tag << 3 | wireType);
};
var MessageWriter = _MessageWriter;
function writeProtobufMessage(value, fun) {
  const w = new MessageWriter();
  fun(w, value);
  return w.data();
}

// node_modules/@libsql/hrana-client/lib-esm/id_alloc.js
var _usedIds, _freeIds;
var IdAlloc = class {
  constructor() {
    // Set of all allocated ids
    __privateAdd(this, _usedIds, void 0);
    // Set of all free ids lower than `#usedIds.size`
    __privateAdd(this, _freeIds, void 0);
    __privateSet(this, _usedIds, /* @__PURE__ */ new Set());
    __privateSet(this, _freeIds, /* @__PURE__ */ new Set());
  }
  // Returns an id that was free, and marks it as used.
  alloc() {
    for (const freeId2 of __privateGet(this, _freeIds)) {
      __privateGet(this, _freeIds).delete(freeId2);
      __privateGet(this, _usedIds).add(freeId2);
      if (!__privateGet(this, _usedIds).has(__privateGet(this, _usedIds).size - 1)) {
        __privateGet(this, _freeIds).add(__privateGet(this, _usedIds).size - 1);
      }
      return freeId2;
    }
    const freeId = __privateGet(this, _usedIds).size;
    __privateGet(this, _usedIds).add(freeId);
    return freeId;
  }
  free(id) {
    if (!__privateGet(this, _usedIds).delete(id)) {
      throw new InternalError("Freeing an id that is not allocated");
    }
    __privateGet(this, _freeIds).delete(__privateGet(this, _usedIds).size);
    if (id < __privateGet(this, _usedIds).size) {
      __privateGet(this, _freeIds).add(id);
    }
  }
};
_usedIds = new WeakMap();
_freeIds = new WeakMap();

// node_modules/@libsql/hrana-client/lib-esm/util.js
function impossible(value, message) {
  throw new InternalError(message);
}

// node_modules/@libsql/hrana-client/lib-esm/value.js
function valueToProto(value) {
  if (value === null) {
    return null;
  } else if (typeof value === "string") {
    return value;
  } else if (typeof value === "number") {
    if (!Number.isFinite(value)) {
      throw new RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");
    }
    return value;
  } else if (typeof value === "bigint") {
    if (value < minInteger || value > maxInteger) {
      throw new RangeError("This bigint value is too large to be represented as a 64-bit integer and passed as argument");
    }
    return value;
  } else if (typeof value === "boolean") {
    return value ? 1n : 0n;
  } else if (value instanceof ArrayBuffer) {
    return new Uint8Array(value);
  } else if (value instanceof Uint8Array) {
    return value;
  } else if (value instanceof Date) {
    return +value.valueOf();
  } else if (typeof value === "object") {
    return "" + value.toString();
  } else {
    throw new TypeError("Unsupported type of value");
  }
}
var minInteger = -9223372036854775808n;
var maxInteger = 9223372036854775807n;
function valueFromProto(value, intMode) {
  if (value === null) {
    return null;
  } else if (typeof value === "number") {
    return value;
  } else if (typeof value === "string") {
    return value;
  } else if (typeof value === "bigint") {
    if (intMode === "number") {
      const num = Number(value);
      if (!Number.isSafeInteger(num)) {
        throw new RangeError("Received integer which is too large to be safely represented as a JavaScript number");
      }
      return num;
    } else if (intMode === "bigint") {
      return value;
    } else if (intMode === "string") {
      return "" + value;
    } else {
      throw new MisuseError("Invalid value for IntMode");
    }
  } else if (value instanceof Uint8Array) {
    return value.slice().buffer;
  } else if (value === void 0) {
    throw new ProtoError("Received unrecognized type of Value");
  } else {
    throw impossible(value, "Impossible type of Value");
  }
}

// node_modules/@libsql/hrana-client/lib-esm/result.js
function stmtResultFromProto(result) {
  return {
    affectedRowCount: result.affectedRowCount,
    lastInsertRowid: result.lastInsertRowid,
    columnNames: result.cols.map((col) => col.name),
    columnDecltypes: result.cols.map((col) => col.decltype)
  };
}
function rowsResultFromProto(result, intMode) {
  const stmtResult = stmtResultFromProto(result);
  const rows = result.rows.map((row) => rowFromProto(stmtResult.columnNames, row, intMode));
  return { ...stmtResult, rows };
}
function rowResultFromProto(result, intMode) {
  const stmtResult = stmtResultFromProto(result);
  let row;
  if (result.rows.length > 0) {
    row = rowFromProto(stmtResult.columnNames, result.rows[0], intMode);
  }
  return { ...stmtResult, row };
}
function valueResultFromProto(result, intMode) {
  const stmtResult = stmtResultFromProto(result);
  let value;
  if (result.rows.length > 0 && stmtResult.columnNames.length > 0) {
    value = valueFromProto(result.rows[0][0], intMode);
  }
  return { ...stmtResult, value };
}
function rowFromProto(colNames, values, intMode) {
  const row = {};
  Object.defineProperty(row, "length", { value: values.length });
  for (let i = 0; i < values.length; ++i) {
    const value = valueFromProto(values[i], intMode);
    Object.defineProperty(row, i, { value });
    const colName = colNames[i];
    if (colName !== void 0 && !Object.hasOwn(row, colName)) {
      Object.defineProperty(row, colName, { value, enumerable: true, configurable: true, writable: true });
    }
  }
  return row;
}
function errorFromProto(error) {
  return new ResponseError(error.message, error);
}

// node_modules/@libsql/hrana-client/lib-esm/sql.js
var _owner, _sqlId, _closed;
var Sql = class {
  /** @private */
  constructor(owner, sqlId) {
    __privateAdd(this, _owner, void 0);
    __privateAdd(this, _sqlId, void 0);
    __privateAdd(this, _closed, void 0);
    __privateSet(this, _owner, owner);
    __privateSet(this, _sqlId, sqlId);
    __privateSet(this, _closed, void 0);
  }
  /** @private */
  _getSqlId(owner) {
    if (__privateGet(this, _owner) !== owner) {
      throw new MisuseError("Attempted to use SQL text opened with other object");
    } else if (__privateGet(this, _closed) !== void 0) {
      throw new ClosedError("SQL text is closed", __privateGet(this, _closed));
    }
    return __privateGet(this, _sqlId);
  }
  /** Remove the SQL text from the server, releasing resouces. */
  close() {
    this._setClosed(new ClientError("SQL text was manually closed"));
  }
  /** @private */
  _setClosed(error) {
    if (__privateGet(this, _closed) === void 0) {
      __privateSet(this, _closed, error);
      __privateGet(this, _owner)._closeSql(__privateGet(this, _sqlId));
    }
  }
  /** True if the SQL text is closed (removed from the server). */
  get closed() {
    return __privateGet(this, _closed) !== void 0;
  }
};
_owner = new WeakMap();
_sqlId = new WeakMap();
_closed = new WeakMap();
function sqlToProto(owner, sql) {
  if (sql instanceof Sql) {
    return { sqlId: sql._getSqlId(owner) };
  } else {
    return { sql: "" + sql };
  }
}

// node_modules/@libsql/hrana-client/lib-esm/queue.js
var _pushStack, _shiftStack;
var Queue = class {
  constructor() {
    __privateAdd(this, _pushStack, void 0);
    __privateAdd(this, _shiftStack, void 0);
    __privateSet(this, _pushStack, []);
    __privateSet(this, _shiftStack, []);
  }
  get length() {
    return __privateGet(this, _pushStack).length + __privateGet(this, _shiftStack).length;
  }
  push(elem) {
    __privateGet(this, _pushStack).push(elem);
  }
  shift() {
    if (__privateGet(this, _shiftStack).length === 0 && __privateGet(this, _pushStack).length > 0) {
      __privateSet(this, _shiftStack, __privateGet(this, _pushStack).reverse());
      __privateSet(this, _pushStack, []);
    }
    return __privateGet(this, _shiftStack).pop();
  }
  first() {
    return __privateGet(this, _shiftStack).length !== 0 ? __privateGet(this, _shiftStack)[__privateGet(this, _shiftStack).length - 1] : __privateGet(this, _pushStack)[0];
  }
};
_pushStack = new WeakMap();
_shiftStack = new WeakMap();

// node_modules/@libsql/hrana-client/lib-esm/stmt.js
var Stmt = class {
  /** Initialize the statement with given SQL text. */
  constructor(sql) {
    /** The SQL statement text. */
    __publicField(this, "sql");
    /** @private */
    __publicField(this, "_args");
    /** @private */
    __publicField(this, "_namedArgs");
    this.sql = sql;
    this._args = [];
    this._namedArgs = /* @__PURE__ */ new Map();
  }
  /** Binds positional parameters from the given `values`. All previous positional bindings are cleared. */
  bindIndexes(values) {
    this._args.length = 0;
    for (const value of values) {
      this._args.push(valueToProto(value));
    }
    return this;
  }
  /** Binds a parameter by a 1-based index. */
  bindIndex(index, value) {
    if (index !== (index | 0) || index <= 0) {
      throw new RangeError("Index of a positional argument must be positive integer");
    }
    while (this._args.length < index) {
      this._args.push(null);
    }
    this._args[index - 1] = valueToProto(value);
    return this;
  }
  /** Binds a parameter by name. */
  bindName(name, value) {
    this._namedArgs.set(name, valueToProto(value));
    return this;
  }
  /** Clears all bindings. */
  unbindAll() {
    this._args.length = 0;
    this._namedArgs.clear();
    return this;
  }
};
function stmtToProto(sqlOwner, stmt, wantRows) {
  let inSql;
  let args = [];
  let namedArgs = [];
  if (stmt instanceof Stmt) {
    inSql = stmt.sql;
    args = stmt._args;
    for (const [name, value] of stmt._namedArgs.entries()) {
      namedArgs.push({ name, value });
    }
  } else if (Array.isArray(stmt)) {
    inSql = stmt[0];
    if (Array.isArray(stmt[1])) {
      args = stmt[1].map((arg) => valueToProto(arg));
    } else {
      namedArgs = Object.entries(stmt[1]).map(([name, value]) => {
        return { name, value: valueToProto(value) };
      });
    }
  } else {
    inSql = stmt;
  }
  const { sql, sqlId } = sqlToProto(sqlOwner, inSql);
  return { sql, sqlId, args, namedArgs, wantRows };
}

// node_modules/@libsql/hrana-client/lib-esm/batch.js
var _useCursor, _executed;
var Batch = class {
  /** @private */
  constructor(stream, useCursor) {
    /** @private */
    __publicField(this, "_stream");
    __privateAdd(this, _useCursor, void 0);
    /** @private */
    __publicField(this, "_steps");
    __privateAdd(this, _executed, void 0);
    this._stream = stream;
    __privateSet(this, _useCursor, useCursor);
    this._steps = [];
    __privateSet(this, _executed, false);
  }
  /** Return a builder for adding a step to the batch. */
  step() {
    return new BatchStep(this);
  }
  /** Execute the batch. */
  execute() {
    if (__privateGet(this, _executed)) {
      throw new MisuseError("This batch has already been executed");
    }
    __privateSet(this, _executed, true);
    const batch = {
      steps: this._steps.map((step) => step.proto)
    };
    if (__privateGet(this, _useCursor)) {
      return executeCursor(this._stream, this._steps, batch);
    } else {
      return executeRegular(this._stream, this._steps, batch);
    }
  }
};
_useCursor = new WeakMap();
_executed = new WeakMap();
function executeRegular(stream, steps, batch) {
  return stream._batch(batch).then((result) => {
    for (let step = 0; step < steps.length; ++step) {
      const stepResult = result.stepResults.get(step);
      const stepError = result.stepErrors.get(step);
      steps[step].callback(stepResult, stepError);
    }
  });
}
async function executeCursor(stream, steps, batch) {
  const cursor = await stream._openCursor(batch);
  try {
    let nextStep = 0;
    let beginEntry = void 0;
    let rows = [];
    for (; ; ) {
      const entry = await cursor.next();
      if (entry === void 0) {
        break;
      }
      if (entry.type === "step_begin") {
        if (entry.step < nextStep || entry.step >= steps.length) {
          throw new ProtoError("Server produced StepBeginEntry for unexpected step");
        } else if (beginEntry !== void 0) {
          throw new ProtoError("Server produced StepBeginEntry before terminating previous step");
        }
        for (let step = nextStep; step < entry.step; ++step) {
          steps[step].callback(void 0, void 0);
        }
        nextStep = entry.step + 1;
        beginEntry = entry;
        rows = [];
      } else if (entry.type === "step_end") {
        if (beginEntry === void 0) {
          throw new ProtoError("Server produced StepEndEntry but no step is active");
        }
        const stmtResult = {
          cols: beginEntry.cols,
          rows,
          affectedRowCount: entry.affectedRowCount,
          lastInsertRowid: entry.lastInsertRowid
        };
        steps[beginEntry.step].callback(stmtResult, void 0);
        beginEntry = void 0;
        rows = [];
      } else if (entry.type === "step_error") {
        if (beginEntry === void 0) {
          if (entry.step >= steps.length) {
            throw new ProtoError("Server produced StepErrorEntry for unexpected step");
          }
          for (let step = nextStep; step < entry.step; ++step) {
            steps[step].callback(void 0, void 0);
          }
        } else {
          if (entry.step !== beginEntry.step) {
            throw new ProtoError("Server produced StepErrorEntry for unexpected step");
          }
          beginEntry = void 0;
          rows = [];
        }
        steps[entry.step].callback(void 0, entry.error);
        nextStep = entry.step + 1;
      } else if (entry.type === "row") {
        if (beginEntry === void 0) {
          throw new ProtoError("Server produced RowEntry but no step is active");
        }
        rows.push(entry.row);
      } else if (entry.type === "error") {
        throw errorFromProto(entry.error);
      } else if (entry.type === "none") {
        throw new ProtoError("Server produced unrecognized CursorEntry");
      } else {
        throw impossible(entry, "Impossible CursorEntry");
      }
    }
    if (beginEntry !== void 0) {
      throw new ProtoError("Server closed Cursor before terminating active step");
    }
    for (let step = nextStep; step < steps.length; ++step) {
      steps[step].callback(void 0, void 0);
    }
  } finally {
    cursor.close();
  }
}
var _conds, _add, add_fn;
var BatchStep = class {
  /** @private */
  constructor(batch) {
    __privateAdd(this, _add);
    /** @private */
    __publicField(this, "_batch");
    __privateAdd(this, _conds, void 0);
    /** @private */
    __publicField(this, "_index");
    this._batch = batch;
    __privateSet(this, _conds, []);
    this._index = void 0;
  }
  /** Add the condition that needs to be satisfied to execute the statement. If you use this method multiple
   * times, we join the conditions with a logical AND. */
  condition(cond) {
    __privateGet(this, _conds).push(cond._proto);
    return this;
  }
  /** Add a statement that returns rows. */
  query(stmt) {
    return __privateMethod(this, _add, add_fn).call(this, stmt, true, rowsResultFromProto);
  }
  /** Add a statement that returns at most a single row. */
  queryRow(stmt) {
    return __privateMethod(this, _add, add_fn).call(this, stmt, true, rowResultFromProto);
  }
  /** Add a statement that returns at most a single value. */
  queryValue(stmt) {
    return __privateMethod(this, _add, add_fn).call(this, stmt, true, valueResultFromProto);
  }
  /** Add a statement without returning rows. */
  run(stmt) {
    return __privateMethod(this, _add, add_fn).call(this, stmt, false, stmtResultFromProto);
  }
};
_conds = new WeakMap();
_add = new WeakSet();
add_fn = function(inStmt, wantRows, fromProto) {
  if (this._index !== void 0) {
    throw new MisuseError("This BatchStep has already been added to the batch");
  }
  const stmt = stmtToProto(this._batch._stream._sqlOwner(), inStmt, wantRows);
  let condition;
  if (__privateGet(this, _conds).length === 0) {
    condition = void 0;
  } else if (__privateGet(this, _conds).length === 1) {
    condition = __privateGet(this, _conds)[0];
  } else {
    condition = { type: "and", conds: __privateGet(this, _conds).slice() };
  }
  const proto = { stmt, condition };
  return new Promise((outputCallback, errorCallback) => {
    const callback = (stepResult, stepError) => {
      if (stepResult !== void 0 && stepError !== void 0) {
        errorCallback(new ProtoError("Server returned both result and error"));
      } else if (stepError !== void 0) {
        errorCallback(errorFromProto(stepError));
      } else if (stepResult !== void 0) {
        outputCallback(fromProto(stepResult, this._batch._stream.intMode));
      } else {
        outputCallback(void 0);
      }
    };
    this._index = this._batch._steps.length;
    this._batch._steps.push({ proto, callback });
  });
};
var BatchCond = class _BatchCond {
  /** @private */
  constructor(batch, proto) {
    /** @private */
    __publicField(this, "_batch");
    /** @private */
    __publicField(this, "_proto");
    this._batch = batch;
    this._proto = proto;
  }
  /** Create a condition that evaluates to true when the given step executes successfully.
   *
   * If the given step fails error or is skipped because its condition evaluated to false, this
   * condition evaluates to false.
   */
  static ok(step) {
    return new _BatchCond(step._batch, { type: "ok", step: stepIndex(step) });
  }
  /** Create a condition that evaluates to true when the given step fails.
   *
   * If the given step succeeds or is skipped because its condition evaluated to false, this condition
   * evaluates to false.
   */
  static error(step) {
    return new _BatchCond(step._batch, { type: "error", step: stepIndex(step) });
  }
  /** Create a condition that is a logical negation of another condition.
   */
  static not(cond) {
    return new _BatchCond(cond._batch, { type: "not", cond: cond._proto });
  }
  /** Create a condition that is a logical AND of other conditions.
   */
  static and(batch, conds) {
    for (const cond of conds) {
      checkCondBatch(batch, cond);
    }
    return new _BatchCond(batch, { type: "and", conds: conds.map((e) => e._proto) });
  }
  /** Create a condition that is a logical OR of other conditions.
   */
  static or(batch, conds) {
    for (const cond of conds) {
      checkCondBatch(batch, cond);
    }
    return new _BatchCond(batch, { type: "or", conds: conds.map((e) => e._proto) });
  }
  /** Create a condition that evaluates to true when the SQL connection is in autocommit mode (not inside an
   * explicit transaction). This requires protocol version 3 or higher.
   */
  static isAutocommit(batch) {
    batch._stream.client()._ensureVersion(3, "BatchCond.isAutocommit()");
    return new _BatchCond(batch, { type: "is_autocommit" });
  }
};
function stepIndex(step) {
  if (step._index === void 0) {
    throw new MisuseError("Cannot add a condition referencing a step that has not been added to the batch");
  }
  return step._index;
}
function checkCondBatch(expectedBatch, cond) {
  if (cond._batch !== expectedBatch) {
    throw new MisuseError("Cannot mix BatchCond objects for different Batch objects");
  }
}

// node_modules/@libsql/hrana-client/lib-esm/describe.js
function describeResultFromProto(result) {
  return {
    paramNames: result.params.map((p) => p.name),
    columns: result.cols,
    isExplain: result.isExplain,
    isReadonly: result.isReadonly
  };
}

// node_modules/@libsql/hrana-client/lib-esm/stream.js
var _execute, execute_fn;
var Stream = class {
  /** @private */
  constructor(intMode) {
    __privateAdd(this, _execute);
    /** Representation of integers returned from the database. See {@link IntMode}.
     *
     * This value affects the results of all operations on this stream.
     */
    __publicField(this, "intMode");
    this.intMode = intMode;
  }
  /** Execute a statement and return rows. */
  query(stmt) {
    return __privateMethod(this, _execute, execute_fn).call(this, stmt, true, rowsResultFromProto);
  }
  /** Execute a statement and return at most a single row. */
  queryRow(stmt) {
    return __privateMethod(this, _execute, execute_fn).call(this, stmt, true, rowResultFromProto);
  }
  /** Execute a statement and return at most a single value. */
  queryValue(stmt) {
    return __privateMethod(this, _execute, execute_fn).call(this, stmt, true, valueResultFromProto);
  }
  /** Execute a statement without returning rows. */
  run(stmt) {
    return __privateMethod(this, _execute, execute_fn).call(this, stmt, false, stmtResultFromProto);
  }
  /** Return a builder for creating and executing a batch.
   *
   * If `useCursor` is true, the batch will be executed using a Hrana cursor, which will stream results from
   * the server to the client, which consumes less memory on the server. This requires protocol version 3 or
   * higher.
   */
  batch(useCursor = false) {
    return new Batch(this, useCursor);
  }
  /** Parse and analyze a statement. This requires protocol version 2 or higher. */
  describe(inSql) {
    const protoSql = sqlToProto(this._sqlOwner(), inSql);
    return this._describe(protoSql).then(describeResultFromProto);
  }
  /** Execute a sequence of statements separated by semicolons. This requires protocol version 2 or higher.
   * */
  sequence(inSql) {
    const protoSql = sqlToProto(this._sqlOwner(), inSql);
    return this._sequence(protoSql);
  }
};
_execute = new WeakSet();
execute_fn = function(inStmt, wantRows, fromProto) {
  const stmt = stmtToProto(this._sqlOwner(), inStmt, wantRows);
  return this._execute(stmt).then((r) => fromProto(r, this.intMode));
};

// node_modules/@libsql/hrana-client/lib-esm/cursor.js
var Cursor = class {
};

// node_modules/@libsql/hrana-client/lib-esm/ws/cursor.js
var fetchChunkSize = 1e3;
var fetchQueueSize = 10;
var _client, _stream, _cursorId, _entryQueue, _fetchQueue, _closed2, _done, _fetch, fetch_fn;
var WsCursor = class extends Cursor {
  /** @private */
  constructor(client, stream, cursorId) {
    super();
    __privateAdd(this, _fetch);
    __privateAdd(this, _client, void 0);
    __privateAdd(this, _stream, void 0);
    __privateAdd(this, _cursorId, void 0);
    __privateAdd(this, _entryQueue, void 0);
    __privateAdd(this, _fetchQueue, void 0);
    __privateAdd(this, _closed2, void 0);
    __privateAdd(this, _done, void 0);
    __privateSet(this, _client, client);
    __privateSet(this, _stream, stream);
    __privateSet(this, _cursorId, cursorId);
    __privateSet(this, _entryQueue, new Queue());
    __privateSet(this, _fetchQueue, new Queue());
    __privateSet(this, _closed2, void 0);
    __privateSet(this, _done, false);
  }
  /** Fetch the next entry from the cursor. */
  async next() {
    for (; ; ) {
      if (__privateGet(this, _closed2) !== void 0) {
        throw new ClosedError("Cursor is closed", __privateGet(this, _closed2));
      }
      while (!__privateGet(this, _done) && __privateGet(this, _fetchQueue).length < fetchQueueSize) {
        __privateGet(this, _fetchQueue).push(__privateMethod(this, _fetch, fetch_fn).call(this));
      }
      const entry = __privateGet(this, _entryQueue).shift();
      if (__privateGet(this, _done) || entry !== void 0) {
        return entry;
      }
      await __privateGet(this, _fetchQueue).shift().then((response) => {
        if (response === void 0) {
          return;
        }
        for (const entry2 of response.entries) {
          __privateGet(this, _entryQueue).push(entry2);
        }
        __privateGet(this, _done) || __privateSet(this, _done, response.done);
      });
    }
  }
  /** @private */
  _setClosed(error) {
    if (__privateGet(this, _closed2) !== void 0) {
      return;
    }
    __privateSet(this, _closed2, error);
    __privateGet(this, _stream)._sendCursorRequest(this, {
      type: "close_cursor",
      cursorId: __privateGet(this, _cursorId)
    }).catch(() => void 0);
    __privateGet(this, _stream)._cursorClosed(this);
  }
  /** Close the cursor. */
  close() {
    this._setClosed(new ClientError("Cursor was manually closed"));
  }
  /** True if the cursor is closed. */
  get closed() {
    return __privateGet(this, _closed2) !== void 0;
  }
};
_client = new WeakMap();
_stream = new WeakMap();
_cursorId = new WeakMap();
_entryQueue = new WeakMap();
_fetchQueue = new WeakMap();
_closed2 = new WeakMap();
_done = new WeakMap();
_fetch = new WeakSet();
fetch_fn = function() {
  return __privateGet(this, _stream)._sendCursorRequest(this, {
    type: "fetch_cursor",
    cursorId: __privateGet(this, _cursorId),
    maxCount: fetchChunkSize
  }).then((resp) => resp, (error) => {
    this._setClosed(error);
    return void 0;
  });
};

// node_modules/@libsql/hrana-client/lib-esm/ws/stream.js
var _client2, _streamId, _queue, _cursor, _closing, _closed3, _sendStreamRequest, sendStreamRequest_fn, _pushToQueue, pushToQueue_fn, _flushQueue, flushQueue_fn, _setClosed, setClosed_fn;
var _WsStream = class _WsStream extends Stream {
  /** @private */
  constructor(client, streamId) {
    super(client.intMode);
    __privateAdd(this, _sendStreamRequest);
    __privateAdd(this, _pushToQueue);
    __privateAdd(this, _flushQueue);
    __privateAdd(this, _setClosed);
    __privateAdd(this, _client2, void 0);
    __privateAdd(this, _streamId, void 0);
    __privateAdd(this, _queue, void 0);
    __privateAdd(this, _cursor, void 0);
    __privateAdd(this, _closing, void 0);
    __privateAdd(this, _closed3, void 0);
    __privateSet(this, _client2, client);
    __privateSet(this, _streamId, streamId);
    __privateSet(this, _queue, new Queue());
    __privateSet(this, _cursor, void 0);
    __privateSet(this, _closing, false);
    __privateSet(this, _closed3, void 0);
  }
  /** @private */
  static open(client) {
    const streamId = client._streamIdAlloc.alloc();
    const stream = new _WsStream(client, streamId);
    const responseCallback = () => void 0;
    const errorCallback = (e) => {
      var _a;
      return __privateMethod(_a = stream, _setClosed, setClosed_fn).call(_a, e);
    };
    const request = { type: "open_stream", streamId };
    client._sendRequest(request, { responseCallback, errorCallback });
    return stream;
  }
  /** Get the {@link WsClient} object that this stream belongs to. */
  client() {
    return __privateGet(this, _client2);
  }
  /** @private */
  _sqlOwner() {
    return __privateGet(this, _client2);
  }
  /** @private */
  _execute(stmt) {
    return __privateMethod(this, _sendStreamRequest, sendStreamRequest_fn).call(this, {
      type: "execute",
      streamId: __privateGet(this, _streamId),
      stmt
    }).then((response) => {
      return response.result;
    });
  }
  /** @private */
  _batch(batch) {
    return __privateMethod(this, _sendStreamRequest, sendStreamRequest_fn).call(this, {
      type: "batch",
      streamId: __privateGet(this, _streamId),
      batch
    }).then((response) => {
      return response.result;
    });
  }
  /** @private */
  _describe(protoSql) {
    __privateGet(this, _client2)._ensureVersion(2, "describe()");
    return __privateMethod(this, _sendStreamRequest, sendStreamRequest_fn).call(this, {
      type: "describe",
      streamId: __privateGet(this, _streamId),
      sql: protoSql.sql,
      sqlId: protoSql.sqlId
    }).then((response) => {
      return response.result;
    });
  }
  /** @private */
  _sequence(protoSql) {
    __privateGet(this, _client2)._ensureVersion(2, "sequence()");
    return __privateMethod(this, _sendStreamRequest, sendStreamRequest_fn).call(this, {
      type: "sequence",
      streamId: __privateGet(this, _streamId),
      sql: protoSql.sql,
      sqlId: protoSql.sqlId
    }).then((_response) => {
      return void 0;
    });
  }
  /** Check whether the SQL connection underlying this stream is in autocommit state (i.e., outside of an
   * explicit transaction). This requires protocol version 3 or higher.
   */
  getAutocommit() {
    __privateGet(this, _client2)._ensureVersion(3, "getAutocommit()");
    return __privateMethod(this, _sendStreamRequest, sendStreamRequest_fn).call(this, {
      type: "get_autocommit",
      streamId: __privateGet(this, _streamId)
    }).then((response) => {
      return response.isAutocommit;
    });
  }
  /** @private */
  _openCursor(batch) {
    __privateGet(this, _client2)._ensureVersion(3, "cursor");
    return new Promise((cursorCallback, errorCallback) => {
      __privateMethod(this, _pushToQueue, pushToQueue_fn).call(this, { type: "cursor", batch, cursorCallback, errorCallback });
    });
  }
  /** @private */
  _sendCursorRequest(cursor, request) {
    if (cursor !== __privateGet(this, _cursor)) {
      throw new InternalError("Cursor not associated with the stream attempted to execute a request");
    }
    return new Promise((responseCallback, errorCallback) => {
      if (__privateGet(this, _closed3) !== void 0) {
        errorCallback(new ClosedError("Stream is closed", __privateGet(this, _closed3)));
      } else {
        __privateGet(this, _client2)._sendRequest(request, { responseCallback, errorCallback });
      }
    });
  }
  /** @private */
  _cursorClosed(cursor) {
    if (cursor !== __privateGet(this, _cursor)) {
      throw new InternalError("Cursor was closed, but it was not associated with the stream");
    }
    __privateSet(this, _cursor, void 0);
    __privateMethod(this, _flushQueue, flushQueue_fn).call(this);
  }
  /** Immediately close the stream. */
  close() {
    __privateMethod(this, _setClosed, setClosed_fn).call(this, new ClientError("Stream was manually closed"));
  }
  /** Gracefully close the stream. */
  closeGracefully() {
    __privateSet(this, _closing, true);
    __privateMethod(this, _flushQueue, flushQueue_fn).call(this);
  }
  /** True if the stream is closed or closing. */
  get closed() {
    return __privateGet(this, _closed3) !== void 0 || __privateGet(this, _closing);
  }
};
_client2 = new WeakMap();
_streamId = new WeakMap();
_queue = new WeakMap();
_cursor = new WeakMap();
_closing = new WeakMap();
_closed3 = new WeakMap();
_sendStreamRequest = new WeakSet();
sendStreamRequest_fn = function(request) {
  return new Promise((responseCallback, errorCallback) => {
    __privateMethod(this, _pushToQueue, pushToQueue_fn).call(this, { type: "request", request, responseCallback, errorCallback });
  });
};
_pushToQueue = new WeakSet();
pushToQueue_fn = function(entry) {
  if (__privateGet(this, _closed3) !== void 0) {
    entry.errorCallback(new ClosedError("Stream is closed", __privateGet(this, _closed3)));
  } else if (__privateGet(this, _closing)) {
    entry.errorCallback(new ClosedError("Stream is closing", void 0));
  } else {
    __privateGet(this, _queue).push(entry);
    __privateMethod(this, _flushQueue, flushQueue_fn).call(this);
  }
};
_flushQueue = new WeakSet();
flushQueue_fn = function() {
  for (; ; ) {
    const entry = __privateGet(this, _queue).first();
    if (entry === void 0 && __privateGet(this, _cursor) === void 0 && __privateGet(this, _closing)) {
      __privateMethod(this, _setClosed, setClosed_fn).call(this, new ClientError("Stream was gracefully closed"));
      break;
    } else if ((entry == null ? void 0 : entry.type) === "request" && __privateGet(this, _cursor) === void 0) {
      const { request, responseCallback, errorCallback } = entry;
      __privateGet(this, _queue).shift();
      __privateGet(this, _client2)._sendRequest(request, { responseCallback, errorCallback });
    } else if ((entry == null ? void 0 : entry.type) === "cursor" && __privateGet(this, _cursor) === void 0) {
      const { batch, cursorCallback } = entry;
      __privateGet(this, _queue).shift();
      const cursorId = __privateGet(this, _client2)._cursorIdAlloc.alloc();
      const cursor = new WsCursor(__privateGet(this, _client2), this, cursorId);
      const request = {
        type: "open_cursor",
        streamId: __privateGet(this, _streamId),
        cursorId,
        batch
      };
      const responseCallback = () => void 0;
      const errorCallback = (e) => cursor._setClosed(e);
      __privateGet(this, _client2)._sendRequest(request, { responseCallback, errorCallback });
      __privateSet(this, _cursor, cursor);
      cursorCallback(cursor);
    } else {
      break;
    }
  }
};
_setClosed = new WeakSet();
setClosed_fn = function(error) {
  if (__privateGet(this, _closed3) !== void 0) {
    return;
  }
  __privateSet(this, _closed3, error);
  if (__privateGet(this, _cursor) !== void 0) {
    __privateGet(this, _cursor)._setClosed(error);
  }
  for (; ; ) {
    const entry = __privateGet(this, _queue).shift();
    if (entry !== void 0) {
      entry.errorCallback(error);
    } else {
      break;
    }
  }
  const request = { type: "close_stream", streamId: __privateGet(this, _streamId) };
  const responseCallback = () => __privateGet(this, _client2)._streamIdAlloc.free(__privateGet(this, _streamId));
  const errorCallback = () => void 0;
  __privateGet(this, _client2)._sendRequest(request, { responseCallback, errorCallback });
};
var WsStream = _WsStream;

// node_modules/@libsql/hrana-client/lib-esm/shared/json_encode.js
function Stmt2(w, msg) {
  if (msg.sql !== void 0) {
    w.string("sql", msg.sql);
  }
  if (msg.sqlId !== void 0) {
    w.number("sql_id", msg.sqlId);
  }
  w.arrayObjects("args", msg.args, Value);
  w.arrayObjects("named_args", msg.namedArgs, NamedArg);
  w.boolean("want_rows", msg.wantRows);
}
function NamedArg(w, msg) {
  w.string("name", msg.name);
  w.object("value", msg.value, Value);
}
function Batch2(w, msg) {
  w.arrayObjects("steps", msg.steps, BatchStep2);
}
function BatchStep2(w, msg) {
  if (msg.condition !== void 0) {
    w.object("condition", msg.condition, BatchCond2);
  }
  w.object("stmt", msg.stmt, Stmt2);
}
function BatchCond2(w, msg) {
  w.stringRaw("type", msg.type);
  if (msg.type === "ok" || msg.type === "error") {
    w.number("step", msg.step);
  } else if (msg.type === "not") {
    w.object("cond", msg.cond, BatchCond2);
  } else if (msg.type === "and" || msg.type === "or") {
    w.arrayObjects("conds", msg.conds, BatchCond2);
  } else if (msg.type === "is_autocommit") {
  } else {
    throw impossible(msg, "Impossible type of BatchCond");
  }
}
function Value(w, msg) {
  if (msg === null) {
    w.stringRaw("type", "null");
  } else if (typeof msg === "bigint") {
    w.stringRaw("type", "integer");
    w.stringRaw("value", "" + msg);
  } else if (typeof msg === "number") {
    w.stringRaw("type", "float");
    w.number("value", msg);
  } else if (typeof msg === "string") {
    w.stringRaw("type", "text");
    w.string("value", msg);
  } else if (msg instanceof Uint8Array) {
    w.stringRaw("type", "blob");
    w.stringRaw("base64", gBase64.fromUint8Array(msg));
  } else if (msg === void 0) {
  } else {
    throw impossible(msg, "Impossible type of Value");
  }
}

// node_modules/@libsql/hrana-client/lib-esm/ws/json_encode.js
function ClientMsg(w, msg) {
  w.stringRaw("type", msg.type);
  if (msg.type === "hello") {
    if (msg.jwt !== void 0) {
      w.string("jwt", msg.jwt);
    }
  } else if (msg.type === "request") {
    w.number("request_id", msg.requestId);
    w.object("request", msg.request, Request2);
  } else {
    throw impossible(msg, "Impossible type of ClientMsg");
  }
}
function Request2(w, msg) {
  w.stringRaw("type", msg.type);
  if (msg.type === "open_stream") {
    w.number("stream_id", msg.streamId);
  } else if (msg.type === "close_stream") {
    w.number("stream_id", msg.streamId);
  } else if (msg.type === "execute") {
    w.number("stream_id", msg.streamId);
    w.object("stmt", msg.stmt, Stmt2);
  } else if (msg.type === "batch") {
    w.number("stream_id", msg.streamId);
    w.object("batch", msg.batch, Batch2);
  } else if (msg.type === "open_cursor") {
    w.number("stream_id", msg.streamId);
    w.number("cursor_id", msg.cursorId);
    w.object("batch", msg.batch, Batch2);
  } else if (msg.type === "close_cursor") {
    w.number("cursor_id", msg.cursorId);
  } else if (msg.type === "fetch_cursor") {
    w.number("cursor_id", msg.cursorId);
    w.number("max_count", msg.maxCount);
  } else if (msg.type === "sequence") {
    w.number("stream_id", msg.streamId);
    if (msg.sql !== void 0) {
      w.string("sql", msg.sql);
    }
    if (msg.sqlId !== void 0) {
      w.number("sql_id", msg.sqlId);
    }
  } else if (msg.type === "describe") {
    w.number("stream_id", msg.streamId);
    if (msg.sql !== void 0) {
      w.string("sql", msg.sql);
    }
    if (msg.sqlId !== void 0) {
      w.number("sql_id", msg.sqlId);
    }
  } else if (msg.type === "store_sql") {
    w.number("sql_id", msg.sqlId);
    w.string("sql", msg.sql);
  } else if (msg.type === "close_sql") {
    w.number("sql_id", msg.sqlId);
  } else if (msg.type === "get_autocommit") {
    w.number("stream_id", msg.streamId);
  } else {
    throw impossible(msg, "Impossible type of Request");
  }
}

// node_modules/@libsql/hrana-client/lib-esm/shared/protobuf_encode.js
function Stmt3(w, msg) {
  if (msg.sql !== void 0) {
    w.string(1, msg.sql);
  }
  if (msg.sqlId !== void 0) {
    w.int32(2, msg.sqlId);
  }
  for (const arg of msg.args) {
    w.message(3, arg, Value2);
  }
  for (const arg of msg.namedArgs) {
    w.message(4, arg, NamedArg2);
  }
  w.bool(5, msg.wantRows);
}
function NamedArg2(w, msg) {
  w.string(1, msg.name);
  w.message(2, msg.value, Value2);
}
function Batch3(w, msg) {
  for (const step of msg.steps) {
    w.message(1, step, BatchStep3);
  }
}
function BatchStep3(w, msg) {
  if (msg.condition !== void 0) {
    w.message(1, msg.condition, BatchCond3);
  }
  w.message(2, msg.stmt, Stmt3);
}
function BatchCond3(w, msg) {
  if (msg.type === "ok") {
    w.uint32(1, msg.step);
  } else if (msg.type === "error") {
    w.uint32(2, msg.step);
  } else if (msg.type === "not") {
    w.message(3, msg.cond, BatchCond3);
  } else if (msg.type === "and") {
    w.message(4, msg.conds, BatchCondList);
  } else if (msg.type === "or") {
    w.message(5, msg.conds, BatchCondList);
  } else if (msg.type === "is_autocommit") {
    w.message(6, void 0, Empty);
  } else {
    throw impossible(msg, "Impossible type of BatchCond");
  }
}
function BatchCondList(w, msg) {
  for (const cond of msg) {
    w.message(1, cond, BatchCond3);
  }
}
function Value2(w, msg) {
  if (msg === null) {
    w.message(1, void 0, Empty);
  } else if (typeof msg === "bigint") {
    w.sint64(2, msg);
  } else if (typeof msg === "number") {
    w.double(3, msg);
  } else if (typeof msg === "string") {
    w.string(4, msg);
  } else if (msg instanceof Uint8Array) {
    w.bytes(5, msg);
  } else if (msg === void 0) {
  } else {
    throw impossible(msg, "Impossible type of Value");
  }
}
function Empty(_w, _msg) {
}

// node_modules/@libsql/hrana-client/lib-esm/ws/protobuf_encode.js
function ClientMsg2(w, msg) {
  if (msg.type === "hello") {
    w.message(1, msg, HelloMsg);
  } else if (msg.type === "request") {
    w.message(2, msg, RequestMsg);
  } else {
    throw impossible(msg, "Impossible type of ClientMsg");
  }
}
function HelloMsg(w, msg) {
  if (msg.jwt !== void 0) {
    w.string(1, msg.jwt);
  }
}
function RequestMsg(w, msg) {
  w.int32(1, msg.requestId);
  const request = msg.request;
  if (request.type === "open_stream") {
    w.message(2, request, OpenStreamReq);
  } else if (request.type === "close_stream") {
    w.message(3, request, CloseStreamReq);
  } else if (request.type === "execute") {
    w.message(4, request, ExecuteReq);
  } else if (request.type === "batch") {
    w.message(5, request, BatchReq);
  } else if (request.type === "open_cursor") {
    w.message(6, request, OpenCursorReq);
  } else if (request.type === "close_cursor") {
    w.message(7, request, CloseCursorReq);
  } else if (request.type === "fetch_cursor") {
    w.message(8, request, FetchCursorReq);
  } else if (request.type === "sequence") {
    w.message(9, request, SequenceReq);
  } else if (request.type === "describe") {
    w.message(10, request, DescribeReq);
  } else if (request.type === "store_sql") {
    w.message(11, request, StoreSqlReq);
  } else if (request.type === "close_sql") {
    w.message(12, request, CloseSqlReq);
  } else if (request.type === "get_autocommit") {
    w.message(13, request, GetAutocommitReq);
  } else {
    throw impossible(request, "Impossible type of Request");
  }
}
function OpenStreamReq(w, msg) {
  w.int32(1, msg.streamId);
}
function CloseStreamReq(w, msg) {
  w.int32(1, msg.streamId);
}
function ExecuteReq(w, msg) {
  w.int32(1, msg.streamId);
  w.message(2, msg.stmt, Stmt3);
}
function BatchReq(w, msg) {
  w.int32(1, msg.streamId);
  w.message(2, msg.batch, Batch3);
}
function OpenCursorReq(w, msg) {
  w.int32(1, msg.streamId);
  w.int32(2, msg.cursorId);
  w.message(3, msg.batch, Batch3);
}
function CloseCursorReq(w, msg) {
  w.int32(1, msg.cursorId);
}
function FetchCursorReq(w, msg) {
  w.int32(1, msg.cursorId);
  w.uint32(2, msg.maxCount);
}
function SequenceReq(w, msg) {
  w.int32(1, msg.streamId);
  if (msg.sql !== void 0) {
    w.string(2, msg.sql);
  }
  if (msg.sqlId !== void 0) {
    w.int32(3, msg.sqlId);
  }
}
function DescribeReq(w, msg) {
  w.int32(1, msg.streamId);
  if (msg.sql !== void 0) {
    w.string(2, msg.sql);
  }
  if (msg.sqlId !== void 0) {
    w.int32(3, msg.sqlId);
  }
}
function StoreSqlReq(w, msg) {
  w.int32(1, msg.sqlId);
  w.string(2, msg.sql);
}
function CloseSqlReq(w, msg) {
  w.int32(1, msg.sqlId);
}
function GetAutocommitReq(w, msg) {
  w.int32(1, msg.streamId);
}

// node_modules/@libsql/hrana-client/lib-esm/shared/json_decode.js
function Error2(obj) {
  const message = string(obj["message"]);
  const code = stringOpt(obj["code"]);
  return { message, code };
}
function StmtResult(obj) {
  const cols = arrayObjectsMap(obj["cols"], Col);
  const rows = array(obj["rows"]).map((rowObj) => arrayObjectsMap(rowObj, Value3));
  const affectedRowCount = number(obj["affected_row_count"]);
  const lastInsertRowidStr = stringOpt(obj["last_insert_rowid"]);
  const lastInsertRowid = lastInsertRowidStr !== void 0 ? BigInt(lastInsertRowidStr) : void 0;
  return { cols, rows, affectedRowCount, lastInsertRowid };
}
function Col(obj) {
  const name = stringOpt(obj["name"]);
  const decltype = stringOpt(obj["decltype"]);
  return { name, decltype };
}
function BatchResult(obj) {
  const stepResults = /* @__PURE__ */ new Map();
  array(obj["step_results"]).forEach((value, i) => {
    if (value !== null) {
      stepResults.set(i, StmtResult(object(value)));
    }
  });
  const stepErrors = /* @__PURE__ */ new Map();
  array(obj["step_errors"]).forEach((value, i) => {
    if (value !== null) {
      stepErrors.set(i, Error2(object(value)));
    }
  });
  return { stepResults, stepErrors };
}
function CursorEntry(obj) {
  const type = string(obj["type"]);
  if (type === "step_begin") {
    const step = number(obj["step"]);
    const cols = arrayObjectsMap(obj["cols"], Col);
    return { type: "step_begin", step, cols };
  } else if (type === "step_end") {
    const affectedRowCount = number(obj["affected_row_count"]);
    const lastInsertRowidStr = stringOpt(obj["last_insert_rowid"]);
    const lastInsertRowid = lastInsertRowidStr !== void 0 ? BigInt(lastInsertRowidStr) : void 0;
    return { type: "step_end", affectedRowCount, lastInsertRowid };
  } else if (type === "step_error") {
    const step = number(obj["step"]);
    const error = Error2(object(obj["error"]));
    return { type: "step_error", step, error };
  } else if (type === "row") {
    const row = arrayObjectsMap(obj["row"], Value3);
    return { type: "row", row };
  } else if (type === "error") {
    const error = Error2(object(obj["error"]));
    return { type: "error", error };
  } else {
    throw new ProtoError("Unexpected type of CursorEntry");
  }
}
function DescribeResult(obj) {
  const params = arrayObjectsMap(obj["params"], DescribeParam);
  const cols = arrayObjectsMap(obj["cols"], DescribeCol);
  const isExplain = boolean(obj["is_explain"]);
  const isReadonly = boolean(obj["is_readonly"]);
  return { params, cols, isExplain, isReadonly };
}
function DescribeParam(obj) {
  const name = stringOpt(obj["name"]);
  return { name };
}
function DescribeCol(obj) {
  const name = string(obj["name"]);
  const decltype = stringOpt(obj["decltype"]);
  return { name, decltype };
}
function Value3(obj) {
  const type = string(obj["type"]);
  if (type === "null") {
    return null;
  } else if (type === "integer") {
    const value = string(obj["value"]);
    return BigInt(value);
  } else if (type === "float") {
    return number(obj["value"]);
  } else if (type === "text") {
    return string(obj["value"]);
  } else if (type === "blob") {
    return gBase64.toUint8Array(string(obj["base64"]));
  } else {
    throw new ProtoError("Unexpected type of Value");
  }
}

// node_modules/@libsql/hrana-client/lib-esm/ws/json_decode.js
function ServerMsg(obj) {
  const type = string(obj["type"]);
  if (type === "hello_ok") {
    return { type: "hello_ok" };
  } else if (type === "hello_error") {
    const error = Error2(object(obj["error"]));
    return { type: "hello_error", error };
  } else if (type === "response_ok") {
    const requestId = number(obj["request_id"]);
    const response = Response(object(obj["response"]));
    return { type: "response_ok", requestId, response };
  } else if (type === "response_error") {
    const requestId = number(obj["request_id"]);
    const error = Error2(object(obj["error"]));
    return { type: "response_error", requestId, error };
  } else {
    throw new ProtoError("Unexpected type of ServerMsg");
  }
}
function Response(obj) {
  const type = string(obj["type"]);
  if (type === "open_stream") {
    return { type: "open_stream" };
  } else if (type === "close_stream") {
    return { type: "close_stream" };
  } else if (type === "execute") {
    const result = StmtResult(object(obj["result"]));
    return { type: "execute", result };
  } else if (type === "batch") {
    const result = BatchResult(object(obj["result"]));
    return { type: "batch", result };
  } else if (type === "open_cursor") {
    return { type: "open_cursor" };
  } else if (type === "close_cursor") {
    return { type: "close_cursor" };
  } else if (type === "fetch_cursor") {
    const entries = arrayObjectsMap(obj["entries"], CursorEntry);
    const done = boolean(obj["done"]);
    return { type: "fetch_cursor", entries, done };
  } else if (type === "sequence") {
    return { type: "sequence" };
  } else if (type === "describe") {
    const result = DescribeResult(object(obj["result"]));
    return { type: "describe", result };
  } else if (type === "store_sql") {
    return { type: "store_sql" };
  } else if (type === "close_sql") {
    return { type: "close_sql" };
  } else if (type === "get_autocommit") {
    const isAutocommit = boolean(obj["is_autocommit"]);
    return { type: "get_autocommit", isAutocommit };
  } else {
    throw new ProtoError("Unexpected type of Response");
  }
}

// node_modules/@libsql/hrana-client/lib-esm/shared/protobuf_decode.js
var Error3 = {
  default() {
    return { message: "", code: void 0 };
  },
  1(r, msg) {
    msg.message = r.string();
  },
  2(r, msg) {
    msg.code = r.string();
  }
};
var StmtResult2 = {
  default() {
    return {
      cols: [],
      rows: [],
      affectedRowCount: 0,
      lastInsertRowid: void 0
    };
  },
  1(r, msg) {
    msg.cols.push(r.message(Col2));
  },
  2(r, msg) {
    msg.rows.push(r.message(Row));
  },
  3(r, msg) {
    msg.affectedRowCount = Number(r.uint64());
  },
  4(r, msg) {
    msg.lastInsertRowid = r.sint64();
  }
};
var Col2 = {
  default() {
    return { name: void 0, decltype: void 0 };
  },
  1(r, msg) {
    msg.name = r.string();
  },
  2(r, msg) {
    msg.decltype = r.string();
  }
};
var Row = {
  default() {
    return [];
  },
  1(r, msg) {
    msg.push(r.message(Value4));
  }
};
var BatchResult2 = {
  default() {
    return { stepResults: /* @__PURE__ */ new Map(), stepErrors: /* @__PURE__ */ new Map() };
  },
  1(r, msg) {
    const [key, value] = r.message(BatchResultStepResult);
    msg.stepResults.set(key, value);
  },
  2(r, msg) {
    const [key, value] = r.message(BatchResultStepError);
    msg.stepErrors.set(key, value);
  }
};
var BatchResultStepResult = {
  default() {
    return [0, StmtResult2.default()];
  },
  1(r, msg) {
    msg[0] = r.uint32();
  },
  2(r, msg) {
    msg[1] = r.message(StmtResult2);
  }
};
var BatchResultStepError = {
  default() {
    return [0, Error3.default()];
  },
  1(r, msg) {
    msg[0] = r.uint32();
  },
  2(r, msg) {
    msg[1] = r.message(Error3);
  }
};
var CursorEntry2 = {
  default() {
    return { type: "none" };
  },
  1(r) {
    return r.message(StepBeginEntry);
  },
  2(r) {
    return r.message(StepEndEntry);
  },
  3(r) {
    return r.message(StepErrorEntry);
  },
  4(r) {
    return { type: "row", row: r.message(Row) };
  },
  5(r) {
    return { type: "error", error: r.message(Error3) };
  }
};
var StepBeginEntry = {
  default() {
    return { type: "step_begin", step: 0, cols: [] };
  },
  1(r, msg) {
    msg.step = r.uint32();
  },
  2(r, msg) {
    msg.cols.push(r.message(Col2));
  }
};
var StepEndEntry = {
  default() {
    return {
      type: "step_end",
      affectedRowCount: 0,
      lastInsertRowid: void 0
    };
  },
  1(r, msg) {
    msg.affectedRowCount = r.uint32();
  },
  2(r, msg) {
    msg.lastInsertRowid = r.uint64();
  }
};
var StepErrorEntry = {
  default() {
    return {
      type: "step_error",
      step: 0,
      error: Error3.default()
    };
  },
  1(r, msg) {
    msg.step = r.uint32();
  },
  2(r, msg) {
    msg.error = r.message(Error3);
  }
};
var DescribeResult2 = {
  default() {
    return {
      params: [],
      cols: [],
      isExplain: false,
      isReadonly: false
    };
  },
  1(r, msg) {
    msg.params.push(r.message(DescribeParam2));
  },
  2(r, msg) {
    msg.cols.push(r.message(DescribeCol2));
  },
  3(r, msg) {
    msg.isExplain = r.bool();
  },
  4(r, msg) {
    msg.isReadonly = r.bool();
  }
};
var DescribeParam2 = {
  default() {
    return { name: void 0 };
  },
  1(r, msg) {
    msg.name = r.string();
  }
};
var DescribeCol2 = {
  default() {
    return { name: "", decltype: void 0 };
  },
  1(r, msg) {
    msg.name = r.string();
  },
  2(r, msg) {
    msg.decltype = r.string();
  }
};
var Value4 = {
  default() {
    return void 0;
  },
  1(r) {
    return null;
  },
  2(r) {
    return r.sint64();
  },
  3(r) {
    return r.double();
  },
  4(r) {
    return r.string();
  },
  5(r) {
    return r.bytes();
  }
};

// node_modules/@libsql/hrana-client/lib-esm/ws/protobuf_decode.js
var ServerMsg2 = {
  default() {
    return { type: "none" };
  },
  1(r) {
    return { type: "hello_ok" };
  },
  2(r) {
    return r.message(HelloErrorMsg);
  },
  3(r) {
    return r.message(ResponseOkMsg);
  },
  4(r) {
    return r.message(ResponseErrorMsg);
  }
};
var HelloErrorMsg = {
  default() {
    return { type: "hello_error", error: Error3.default() };
  },
  1(r, msg) {
    msg.error = r.message(Error3);
  }
};
var ResponseErrorMsg = {
  default() {
    return { type: "response_error", requestId: 0, error: Error3.default() };
  },
  1(r, msg) {
    msg.requestId = r.int32();
  },
  2(r, msg) {
    msg.error = r.message(Error3);
  }
};
var ResponseOkMsg = {
  default() {
    return {
      type: "response_ok",
      requestId: 0,
      response: { type: "none" }
    };
  },
  1(r, msg) {
    msg.requestId = r.int32();
  },
  2(r, msg) {
    msg.response = { type: "open_stream" };
  },
  3(r, msg) {
    msg.response = { type: "close_stream" };
  },
  4(r, msg) {
    msg.response = r.message(ExecuteResp);
  },
  5(r, msg) {
    msg.response = r.message(BatchResp);
  },
  6(r, msg) {
    msg.response = { type: "open_cursor" };
  },
  7(r, msg) {
    msg.response = { type: "close_cursor" };
  },
  8(r, msg) {
    msg.response = r.message(FetchCursorResp);
  },
  9(r, msg) {
    msg.response = { type: "sequence" };
  },
  10(r, msg) {
    msg.response = r.message(DescribeResp);
  },
  11(r, msg) {
    msg.response = { type: "store_sql" };
  },
  12(r, msg) {
    msg.response = { type: "close_sql" };
  },
  13(r, msg) {
    msg.response = r.message(GetAutocommitResp);
  }
};
var ExecuteResp = {
  default() {
    return { type: "execute", result: StmtResult2.default() };
  },
  1(r, msg) {
    msg.result = r.message(StmtResult2);
  }
};
var BatchResp = {
  default() {
    return { type: "batch", result: BatchResult2.default() };
  },
  1(r, msg) {
    msg.result = r.message(BatchResult2);
  }
};
var FetchCursorResp = {
  default() {
    return { type: "fetch_cursor", entries: [], done: false };
  },
  1(r, msg) {
    msg.entries.push(r.message(CursorEntry2));
  },
  2(r, msg) {
    msg.done = r.bool();
  }
};
var DescribeResp = {
  default() {
    return { type: "describe", result: DescribeResult2.default() };
  },
  1(r, msg) {
    msg.result = r.message(DescribeResult2);
  }
};
var GetAutocommitResp = {
  default() {
    return { type: "get_autocommit", isAutocommit: false };
  },
  1(r, msg) {
    msg.isAutocommit = r.bool();
  }
};

// node_modules/@libsql/hrana-client/lib-esm/ws/client.js
var subprotocolsV2 = /* @__PURE__ */ new Map([
  ["hrana2", { version: 2, encoding: "json" }],
  ["hrana1", { version: 1, encoding: "json" }]
]);
var subprotocolsV3 = /* @__PURE__ */ new Map([
  ["hrana3-protobuf", { version: 3, encoding: "protobuf" }],
  ["hrana3", { version: 3, encoding: "json" }],
  ["hrana2", { version: 2, encoding: "json" }],
  ["hrana1", { version: 1, encoding: "json" }]
]);
var _socket, _openCallbacks, _opened, _closed4, _recvdHello, _subprotocol, _getVersionCalled, _responseMap, _requestIdAlloc, _sqlIdAlloc, _send, send_fn, _onSocketOpen, onSocketOpen_fn, _sendToSocket, sendToSocket_fn, _onSocketError, onSocketError_fn, _onSocketClose, onSocketClose_fn, _setClosed2, setClosed_fn2, _onSocketMessage, onSocketMessage_fn, _handleMsg, handleMsg_fn;
var WsClient = class extends Client {
  /** @private */
  constructor(socket, jwt) {
    super();
    // Send (or enqueue to send) a message to the server.
    __privateAdd(this, _send);
    // The socket transitioned from CONNECTING to OPEN
    __privateAdd(this, _onSocketOpen);
    __privateAdd(this, _sendToSocket);
    // The socket encountered an error.
    __privateAdd(this, _onSocketError);
    // The socket was closed.
    __privateAdd(this, _onSocketClose);
    // Close the client with the given error.
    __privateAdd(this, _setClosed2);
    // We received a message from the socket.
    __privateAdd(this, _onSocketMessage);
    // Handle a message from the server.
    __privateAdd(this, _handleMsg);
    __privateAdd(this, _socket, void 0);
    // List of callbacks that we queue until the socket transitions from the CONNECTING to the OPEN state.
    __privateAdd(this, _openCallbacks, void 0);
    // Have we already transitioned from CONNECTING to OPEN and fired the callbacks in #openCallbacks?
    __privateAdd(this, _opened, void 0);
    // Stores the error that caused us to close the client (and the socket). If we are not closed, this is
    // `undefined`.
    __privateAdd(this, _closed4, void 0);
    // Have we received a response to our "hello" from the server?
    __privateAdd(this, _recvdHello, void 0);
    // Subprotocol negotiated with the server. It is only available after the socket transitions to the OPEN
    // state.
    __privateAdd(this, _subprotocol, void 0);
    // Has the `getVersion()` function been called? This is only used to validate that the API is used
    // correctly.
    __privateAdd(this, _getVersionCalled, void 0);
    // A map from request id to the responses that we expect to receive from the server.
    __privateAdd(this, _responseMap, void 0);
    // An allocator of request ids.
    __privateAdd(this, _requestIdAlloc, void 0);
    // An allocator of stream ids.
    /** @private */
    __publicField(this, "_streamIdAlloc");
    // An allocator of cursor ids.
    /** @private */
    __publicField(this, "_cursorIdAlloc");
    // An allocator of SQL text ids.
    __privateAdd(this, _sqlIdAlloc, void 0);
    __privateSet(this, _socket, socket);
    __privateSet(this, _openCallbacks, []);
    __privateSet(this, _opened, false);
    __privateSet(this, _closed4, void 0);
    __privateSet(this, _recvdHello, false);
    __privateSet(this, _subprotocol, void 0);
    __privateSet(this, _getVersionCalled, false);
    __privateSet(this, _responseMap, /* @__PURE__ */ new Map());
    __privateSet(this, _requestIdAlloc, new IdAlloc());
    this._streamIdAlloc = new IdAlloc();
    this._cursorIdAlloc = new IdAlloc();
    __privateSet(this, _sqlIdAlloc, new IdAlloc());
    __privateGet(this, _socket).binaryType = "arraybuffer";
    __privateGet(this, _socket).addEventListener("open", () => __privateMethod(this, _onSocketOpen, onSocketOpen_fn).call(this));
    __privateGet(this, _socket).addEventListener("close", (event) => __privateMethod(this, _onSocketClose, onSocketClose_fn).call(this, event));
    __privateGet(this, _socket).addEventListener("error", (event) => __privateMethod(this, _onSocketError, onSocketError_fn).call(this, event));
    __privateGet(this, _socket).addEventListener("message", (event) => __privateMethod(this, _onSocketMessage, onSocketMessage_fn).call(this, event));
    __privateMethod(this, _send, send_fn).call(this, { type: "hello", jwt });
  }
  /** Get the protocol version negotiated with the server, possibly waiting until the socket is open. */
  getVersion() {
    return new Promise((versionCallback, errorCallback) => {
      __privateSet(this, _getVersionCalled, true);
      if (__privateGet(this, _closed4) !== void 0) {
        errorCallback(__privateGet(this, _closed4));
      } else if (!__privateGet(this, _opened)) {
        const openCallback = () => versionCallback(__privateGet(this, _subprotocol).version);
        __privateGet(this, _openCallbacks).push({ openCallback, errorCallback });
      } else {
        versionCallback(__privateGet(this, _subprotocol).version);
      }
    });
  }
  // Make sure that the negotiated version is at least `minVersion`.
  /** @private */
  _ensureVersion(minVersion, feature) {
    if (__privateGet(this, _subprotocol) === void 0 || !__privateGet(this, _getVersionCalled)) {
      throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, but the version supported by the WebSocket server is not yet known. Use Client.getVersion() to wait until the version is available.`);
    } else if (__privateGet(this, _subprotocol).version < minVersion) {
      throw new ProtocolVersionError(`${feature} is supported on protocol version ${minVersion} and higher, but the WebSocket server only supports version ${__privateGet(this, _subprotocol).version}`);
    }
  }
  // Send a request to the server and invoke a callback when we get the response.
  /** @private */
  _sendRequest(request, callbacks) {
    if (__privateGet(this, _closed4) !== void 0) {
      callbacks.errorCallback(new ClosedError("Client is closed", __privateGet(this, _closed4)));
      return;
    }
    const requestId = __privateGet(this, _requestIdAlloc).alloc();
    __privateGet(this, _responseMap).set(requestId, { ...callbacks, type: request.type });
    __privateMethod(this, _send, send_fn).call(this, { type: "request", requestId, request });
  }
  /** Open a {@link WsStream}, a stream for executing SQL statements. */
  openStream() {
    return WsStream.open(this);
  }
  /** Cache a SQL text on the server. This requires protocol version 2 or higher. */
  storeSql(sql) {
    this._ensureVersion(2, "storeSql()");
    const sqlId = __privateGet(this, _sqlIdAlloc).alloc();
    const sqlObj = new Sql(this, sqlId);
    const responseCallback = () => void 0;
    const errorCallback = (e) => sqlObj._setClosed(e);
    const request = { type: "store_sql", sqlId, sql };
    this._sendRequest(request, { responseCallback, errorCallback });
    return sqlObj;
  }
  /** @private */
  _closeSql(sqlId) {
    if (__privateGet(this, _closed4) !== void 0) {
      return;
    }
    const responseCallback = () => __privateGet(this, _sqlIdAlloc).free(sqlId);
    const errorCallback = (e) => __privateMethod(this, _setClosed2, setClosed_fn2).call(this, e);
    const request = { type: "close_sql", sqlId };
    this._sendRequest(request, { responseCallback, errorCallback });
  }
  /** Close the client and the WebSocket. */
  close() {
    __privateMethod(this, _setClosed2, setClosed_fn2).call(this, new ClientError("Client was manually closed"));
  }
  /** True if the client is closed. */
  get closed() {
    return __privateGet(this, _closed4) !== void 0;
  }
};
_socket = new WeakMap();
_openCallbacks = new WeakMap();
_opened = new WeakMap();
_closed4 = new WeakMap();
_recvdHello = new WeakMap();
_subprotocol = new WeakMap();
_getVersionCalled = new WeakMap();
_responseMap = new WeakMap();
_requestIdAlloc = new WeakMap();
_sqlIdAlloc = new WeakMap();
_send = new WeakSet();
send_fn = function(msg) {
  if (__privateGet(this, _closed4) !== void 0) {
    throw new InternalError("Trying to send a message on a closed client");
  }
  if (__privateGet(this, _opened)) {
    __privateMethod(this, _sendToSocket, sendToSocket_fn).call(this, msg);
  } else {
    const openCallback = () => __privateMethod(this, _sendToSocket, sendToSocket_fn).call(this, msg);
    const errorCallback = () => void 0;
    __privateGet(this, _openCallbacks).push({ openCallback, errorCallback });
  }
};
_onSocketOpen = new WeakSet();
onSocketOpen_fn = function() {
  const protocol = __privateGet(this, _socket).protocol;
  if (protocol === void 0) {
    __privateMethod(this, _setClosed2, setClosed_fn2).call(this, new ClientError("The `WebSocket.protocol` property is undefined. This most likely means that the WebSocket implementation provided by the environment is broken. If you are using Miniflare 2, please update to Miniflare 3, which fixes this problem."));
    return;
  } else if (protocol === "") {
    __privateSet(this, _subprotocol, { version: 1, encoding: "json" });
  } else {
    __privateSet(this, _subprotocol, subprotocolsV3.get(protocol));
    if (__privateGet(this, _subprotocol) === void 0) {
      __privateMethod(this, _setClosed2, setClosed_fn2).call(this, new ProtoError(`Unrecognized WebSocket subprotocol: ${JSON.stringify(protocol)}`));
      return;
    }
  }
  for (const callbacks of __privateGet(this, _openCallbacks)) {
    callbacks.openCallback();
  }
  __privateGet(this, _openCallbacks).length = 0;
  __privateSet(this, _opened, true);
};
_sendToSocket = new WeakSet();
sendToSocket_fn = function(msg) {
  const encoding = __privateGet(this, _subprotocol).encoding;
  if (encoding === "json") {
    const jsonMsg = writeJsonObject(msg, ClientMsg);
    __privateGet(this, _socket).send(jsonMsg);
  } else if (encoding === "protobuf") {
    const protobufMsg = writeProtobufMessage(msg, ClientMsg2);
    __privateGet(this, _socket).send(protobufMsg);
  } else {
    throw impossible(encoding, "Impossible encoding");
  }
};
_onSocketError = new WeakSet();
onSocketError_fn = function(event) {
  const eventMessage = event.message;
  const message = eventMessage ?? "WebSocket was closed due to an error";
  __privateMethod(this, _setClosed2, setClosed_fn2).call(this, new WebSocketError(message));
};
_onSocketClose = new WeakSet();
onSocketClose_fn = function(event) {
  let message = `WebSocket was closed with code ${event.code}`;
  if (event.reason) {
    message += `: ${event.reason}`;
  }
  __privateMethod(this, _setClosed2, setClosed_fn2).call(this, new WebSocketError(message));
};
_setClosed2 = new WeakSet();
setClosed_fn2 = function(error) {
  if (__privateGet(this, _closed4) !== void 0) {
    return;
  }
  __privateSet(this, _closed4, error);
  for (const callbacks of __privateGet(this, _openCallbacks)) {
    callbacks.errorCallback(error);
  }
  __privateGet(this, _openCallbacks).length = 0;
  for (const [requestId, responseState] of __privateGet(this, _responseMap).entries()) {
    responseState.errorCallback(error);
    __privateGet(this, _requestIdAlloc).free(requestId);
  }
  __privateGet(this, _responseMap).clear();
  __privateGet(this, _socket).close();
};
_onSocketMessage = new WeakSet();
onSocketMessage_fn = function(event) {
  if (__privateGet(this, _closed4) !== void 0) {
    return;
  }
  try {
    let msg;
    const encoding = __privateGet(this, _subprotocol).encoding;
    if (encoding === "json") {
      if (typeof event.data !== "string") {
        __privateGet(this, _socket).close(3003, "Only text messages are accepted with JSON encoding");
        __privateMethod(this, _setClosed2, setClosed_fn2).call(this, new ProtoError("Received non-text message from server with JSON encoding"));
        return;
      }
      msg = readJsonObject(JSON.parse(event.data), ServerMsg);
    } else if (encoding === "protobuf") {
      if (!(event.data instanceof ArrayBuffer)) {
        __privateGet(this, _socket).close(3003, "Only binary messages are accepted with Protobuf encoding");
        __privateMethod(this, _setClosed2, setClosed_fn2).call(this, new ProtoError("Received non-binary message from server with Protobuf encoding"));
        return;
      }
      msg = readProtobufMessage(new Uint8Array(event.data), ServerMsg2);
    } else {
      throw impossible(encoding, "Impossible encoding");
    }
    __privateMethod(this, _handleMsg, handleMsg_fn).call(this, msg);
  } catch (e) {
    __privateGet(this, _socket).close(3007, "Could not handle message");
    __privateMethod(this, _setClosed2, setClosed_fn2).call(this, e);
  }
};
_handleMsg = new WeakSet();
handleMsg_fn = function(msg) {
  if (msg.type === "none") {
    throw new ProtoError("Received an unrecognized ServerMsg");
  } else if (msg.type === "hello_ok" || msg.type === "hello_error") {
    if (__privateGet(this, _recvdHello)) {
      throw new ProtoError("Received a duplicated hello response");
    }
    __privateSet(this, _recvdHello, true);
    if (msg.type === "hello_error") {
      throw errorFromProto(msg.error);
    }
    return;
  } else if (!__privateGet(this, _recvdHello)) {
    throw new ProtoError("Received a non-hello message before a hello response");
  }
  if (msg.type === "response_ok") {
    const requestId = msg.requestId;
    const responseState = __privateGet(this, _responseMap).get(requestId);
    __privateGet(this, _responseMap).delete(requestId);
    if (responseState === void 0) {
      throw new ProtoError("Received unexpected OK response");
    }
    __privateGet(this, _requestIdAlloc).free(requestId);
    try {
      if (responseState.type !== msg.response.type) {
        console.dir({ responseState, msg });
        throw new ProtoError("Received unexpected type of response");
      }
      responseState.responseCallback(msg.response);
    } catch (e) {
      responseState.errorCallback(e);
      throw e;
    }
  } else if (msg.type === "response_error") {
    const requestId = msg.requestId;
    const responseState = __privateGet(this, _responseMap).get(requestId);
    __privateGet(this, _responseMap).delete(requestId);
    if (responseState === void 0) {
      throw new ProtoError("Received unexpected error response");
    }
    __privateGet(this, _requestIdAlloc).free(requestId);
    responseState.errorCallback(errorFromProto(msg.error));
  } else {
    throw impossible(msg, "Impossible ServerMsg type");
  }
};

// node_modules/@libsql/isomorphic-fetch/web.js
var _fetch2 = fetch;
var _Request = Request;
var _Headers = Headers;

// node_modules/@libsql/hrana-client/lib-esm/queue_microtask.js
var _queueMicrotask;
if (typeof queueMicrotask !== "undefined") {
  _queueMicrotask = queueMicrotask;
} else {
  const resolved = Promise.resolve();
  _queueMicrotask = (callback) => {
    resolved.then(callback);
  };
}

// node_modules/@libsql/hrana-client/lib-esm/byte_queue.js
var _array3, _shiftPos, _pushPos, _ensurePush, ensurePush_fn;
var ByteQueue = class {
  constructor(initialCap) {
    __privateAdd(this, _ensurePush);
    __privateAdd(this, _array3, void 0);
    __privateAdd(this, _shiftPos, void 0);
    __privateAdd(this, _pushPos, void 0);
    __privateSet(this, _array3, new Uint8Array(new ArrayBuffer(initialCap)));
    __privateSet(this, _shiftPos, 0);
    __privateSet(this, _pushPos, 0);
  }
  get length() {
    return __privateGet(this, _pushPos) - __privateGet(this, _shiftPos);
  }
  data() {
    return __privateGet(this, _array3).slice(__privateGet(this, _shiftPos), __privateGet(this, _pushPos));
  }
  push(chunk) {
    __privateMethod(this, _ensurePush, ensurePush_fn).call(this, chunk.byteLength);
    __privateGet(this, _array3).set(chunk, __privateGet(this, _pushPos));
    __privateSet(this, _pushPos, __privateGet(this, _pushPos) + chunk.byteLength);
  }
  shift(length) {
    __privateSet(this, _shiftPos, __privateGet(this, _shiftPos) + length);
  }
};
_array3 = new WeakMap();
_shiftPos = new WeakMap();
_pushPos = new WeakMap();
_ensurePush = new WeakSet();
ensurePush_fn = function(pushLength) {
  if (__privateGet(this, _pushPos) + pushLength <= __privateGet(this, _array3).byteLength) {
    return;
  }
  const filledLength = __privateGet(this, _pushPos) - __privateGet(this, _shiftPos);
  if (filledLength + pushLength <= __privateGet(this, _array3).byteLength && 2 * __privateGet(this, _pushPos) >= __privateGet(this, _array3).byteLength) {
    __privateGet(this, _array3).copyWithin(0, __privateGet(this, _shiftPos), __privateGet(this, _pushPos));
  } else {
    let newCap = __privateGet(this, _array3).byteLength;
    do {
      newCap *= 2;
    } while (filledLength + pushLength > newCap);
    const newArray = new Uint8Array(new ArrayBuffer(newCap));
    newArray.set(__privateGet(this, _array3).slice(__privateGet(this, _shiftPos), __privateGet(this, _pushPos)), 0);
    __privateSet(this, _array3, newArray);
  }
  __privateSet(this, _pushPos, filledLength);
  __privateSet(this, _shiftPos, 0);
};

// node_modules/@libsql/hrana-client/lib-esm/http/json_decode.js
function PipelineRespBody(obj) {
  const baton = stringOpt(obj["baton"]);
  const baseUrl = stringOpt(obj["base_url"]);
  const results = arrayObjectsMap(obj["results"], StreamResult);
  return { baton, baseUrl, results };
}
function StreamResult(obj) {
  const type = string(obj["type"]);
  if (type === "ok") {
    const response = StreamResponse(object(obj["response"]));
    return { type: "ok", response };
  } else if (type === "error") {
    const error = Error2(object(obj["error"]));
    return { type: "error", error };
  } else {
    throw new ProtoError("Unexpected type of StreamResult");
  }
}
function StreamResponse(obj) {
  const type = string(obj["type"]);
  if (type === "close") {
    return { type: "close" };
  } else if (type === "execute") {
    const result = StmtResult(object(obj["result"]));
    return { type: "execute", result };
  } else if (type === "batch") {
    const result = BatchResult(object(obj["result"]));
    return { type: "batch", result };
  } else if (type === "sequence") {
    return { type: "sequence" };
  } else if (type === "describe") {
    const result = DescribeResult(object(obj["result"]));
    return { type: "describe", result };
  } else if (type === "store_sql") {
    return { type: "store_sql" };
  } else if (type === "close_sql") {
    return { type: "close_sql" };
  } else if (type === "get_autocommit") {
    const isAutocommit = boolean(obj["is_autocommit"]);
    return { type: "get_autocommit", isAutocommit };
  } else {
    throw new ProtoError("Unexpected type of StreamResponse");
  }
}
function CursorRespBody(obj) {
  const baton = stringOpt(obj["baton"]);
  const baseUrl = stringOpt(obj["base_url"]);
  return { baton, baseUrl };
}

// node_modules/@libsql/hrana-client/lib-esm/http/protobuf_decode.js
var PipelineRespBody2 = {
  default() {
    return { baton: void 0, baseUrl: void 0, results: [] };
  },
  1(r, msg) {
    msg.baton = r.string();
  },
  2(r, msg) {
    msg.baseUrl = r.string();
  },
  3(r, msg) {
    msg.results.push(r.message(StreamResult2));
  }
};
var StreamResult2 = {
  default() {
    return { type: "none" };
  },
  1(r) {
    return { type: "ok", response: r.message(StreamResponse2) };
  },
  2(r) {
    return { type: "error", error: r.message(Error3) };
  }
};
var StreamResponse2 = {
  default() {
    return { type: "none" };
  },
  1(r) {
    return { type: "close" };
  },
  2(r) {
    return r.message(ExecuteStreamResp);
  },
  3(r) {
    return r.message(BatchStreamResp);
  },
  4(r) {
    return { type: "sequence" };
  },
  5(r) {
    return r.message(DescribeStreamResp);
  },
  6(r) {
    return { type: "store_sql" };
  },
  7(r) {
    return { type: "close_sql" };
  },
  8(r) {
    return r.message(GetAutocommitStreamResp);
  }
};
var ExecuteStreamResp = {
  default() {
    return { type: "execute", result: StmtResult2.default() };
  },
  1(r, msg) {
    msg.result = r.message(StmtResult2);
  }
};
var BatchStreamResp = {
  default() {
    return { type: "batch", result: BatchResult2.default() };
  },
  1(r, msg) {
    msg.result = r.message(BatchResult2);
  }
};
var DescribeStreamResp = {
  default() {
    return { type: "describe", result: DescribeResult2.default() };
  },
  1(r, msg) {
    msg.result = r.message(DescribeResult2);
  }
};
var GetAutocommitStreamResp = {
  default() {
    return { type: "get_autocommit", isAutocommit: false };
  },
  1(r, msg) {
    msg.isAutocommit = r.bool();
  }
};
var CursorRespBody2 = {
  default() {
    return { baton: void 0, baseUrl: void 0 };
  },
  1(r, msg) {
    msg.baton = r.string();
  },
  2(r, msg) {
    msg.baseUrl = r.string();
  }
};

// node_modules/@libsql/hrana-client/lib-esm/http/cursor.js
var _stream2, _encoding, _reader2, _queue2, _closed5, _done2, _nextItem, nextItem_fn, _parseItemJson, parseItemJson_fn, _parseItemProtobuf, parseItemProtobuf_fn;
var HttpCursor = class extends Cursor {
  /** @private */
  constructor(stream, encoding) {
    super();
    __privateAdd(this, _nextItem);
    __privateAdd(this, _parseItemJson);
    __privateAdd(this, _parseItemProtobuf);
    __privateAdd(this, _stream2, void 0);
    __privateAdd(this, _encoding, void 0);
    __privateAdd(this, _reader2, void 0);
    __privateAdd(this, _queue2, void 0);
    __privateAdd(this, _closed5, void 0);
    __privateAdd(this, _done2, void 0);
    __privateSet(this, _stream2, stream);
    __privateSet(this, _encoding, encoding);
    __privateSet(this, _reader2, void 0);
    __privateSet(this, _queue2, new ByteQueue(16 * 1024));
    __privateSet(this, _closed5, void 0);
    __privateSet(this, _done2, false);
  }
  async open(response) {
    if (response.body === null) {
      throw new ProtoError("No response body for cursor request");
    }
    __privateSet(this, _reader2, response.body.getReader());
    const respBody = await __privateMethod(this, _nextItem, nextItem_fn).call(this, CursorRespBody, CursorRespBody2);
    if (respBody === void 0) {
      throw new ProtoError("Empty response to cursor request");
    }
    return respBody;
  }
  /** Fetch the next entry from the cursor. */
  next() {
    return __privateMethod(this, _nextItem, nextItem_fn).call(this, CursorEntry, CursorEntry2);
  }
  /** Close the cursor. */
  close() {
    this._setClosed(new ClientError("Cursor was manually closed"));
  }
  /** @private */
  _setClosed(error) {
    if (__privateGet(this, _closed5) !== void 0) {
      return;
    }
    __privateSet(this, _closed5, error);
    __privateGet(this, _stream2)._cursorClosed(this);
    if (__privateGet(this, _reader2) !== void 0) {
      __privateGet(this, _reader2).cancel();
    }
  }
  /** True if the cursor is closed. */
  get closed() {
    return __privateGet(this, _closed5) !== void 0;
  }
};
_stream2 = new WeakMap();
_encoding = new WeakMap();
_reader2 = new WeakMap();
_queue2 = new WeakMap();
_closed5 = new WeakMap();
_done2 = new WeakMap();
_nextItem = new WeakSet();
nextItem_fn = async function(jsonFun, protobufDef) {
  for (; ; ) {
    if (__privateGet(this, _done2)) {
      return void 0;
    } else if (__privateGet(this, _closed5) !== void 0) {
      throw new ClosedError("Cursor is closed", __privateGet(this, _closed5));
    }
    if (__privateGet(this, _encoding) === "json") {
      const jsonData = __privateMethod(this, _parseItemJson, parseItemJson_fn).call(this);
      if (jsonData !== void 0) {
        const jsonText = new TextDecoder().decode(jsonData);
        const jsonValue = JSON.parse(jsonText);
        return readJsonObject(jsonValue, jsonFun);
      }
    } else if (__privateGet(this, _encoding) === "protobuf") {
      const protobufData = __privateMethod(this, _parseItemProtobuf, parseItemProtobuf_fn).call(this);
      if (protobufData !== void 0) {
        return readProtobufMessage(protobufData, protobufDef);
      }
    } else {
      throw impossible(__privateGet(this, _encoding), "Impossible encoding");
    }
    if (__privateGet(this, _reader2) === void 0) {
      throw new InternalError("Attempted to read from HTTP cursor before it was opened");
    }
    const { value, done } = await __privateGet(this, _reader2).read();
    if (done && __privateGet(this, _queue2).length === 0) {
      __privateSet(this, _done2, true);
    } else if (done) {
      throw new ProtoError("Unexpected end of cursor stream");
    } else {
      __privateGet(this, _queue2).push(value);
    }
  }
};
_parseItemJson = new WeakSet();
parseItemJson_fn = function() {
  const data = __privateGet(this, _queue2).data();
  const newlineByte = 10;
  const newlinePos = data.indexOf(newlineByte);
  if (newlinePos < 0) {
    return void 0;
  }
  const jsonData = data.slice(0, newlinePos);
  __privateGet(this, _queue2).shift(newlinePos + 1);
  return jsonData;
};
_parseItemProtobuf = new WeakSet();
parseItemProtobuf_fn = function() {
  const data = __privateGet(this, _queue2).data();
  let varintValue = 0;
  let varintLength = 0;
  for (; ; ) {
    if (varintLength >= data.byteLength) {
      return void 0;
    }
    const byte = data[varintLength];
    varintValue |= (byte & 127) << 7 * varintLength;
    varintLength += 1;
    if (!(byte & 128)) {
      break;
    }
  }
  if (data.byteLength < varintLength + varintValue) {
    return void 0;
  }
  const protobufData = data.slice(varintLength, varintLength + varintValue);
  __privateGet(this, _queue2).shift(varintLength + varintValue);
  return protobufData;
};

// node_modules/@libsql/hrana-client/lib-esm/http/json_encode.js
function PipelineReqBody(w, msg) {
  if (msg.baton !== void 0) {
    w.string("baton", msg.baton);
  }
  w.arrayObjects("requests", msg.requests, StreamRequest);
}
function StreamRequest(w, msg) {
  w.stringRaw("type", msg.type);
  if (msg.type === "close") {
  } else if (msg.type === "execute") {
    w.object("stmt", msg.stmt, Stmt2);
  } else if (msg.type === "batch") {
    w.object("batch", msg.batch, Batch2);
  } else if (msg.type === "sequence") {
    if (msg.sql !== void 0) {
      w.string("sql", msg.sql);
    }
    if (msg.sqlId !== void 0) {
      w.number("sql_id", msg.sqlId);
    }
  } else if (msg.type === "describe") {
    if (msg.sql !== void 0) {
      w.string("sql", msg.sql);
    }
    if (msg.sqlId !== void 0) {
      w.number("sql_id", msg.sqlId);
    }
  } else if (msg.type === "store_sql") {
    w.number("sql_id", msg.sqlId);
    w.string("sql", msg.sql);
  } else if (msg.type === "close_sql") {
    w.number("sql_id", msg.sqlId);
  } else if (msg.type === "get_autocommit") {
  } else {
    throw impossible(msg, "Impossible type of StreamRequest");
  }
}
function CursorReqBody(w, msg) {
  if (msg.baton !== void 0) {
    w.string("baton", msg.baton);
  }
  w.object("batch", msg.batch, Batch2);
}

// node_modules/@libsql/hrana-client/lib-esm/http/protobuf_encode.js
function PipelineReqBody2(w, msg) {
  if (msg.baton !== void 0) {
    w.string(1, msg.baton);
  }
  for (const req of msg.requests) {
    w.message(2, req, StreamRequest2);
  }
}
function StreamRequest2(w, msg) {
  if (msg.type === "close") {
    w.message(1, msg, CloseStreamReq2);
  } else if (msg.type === "execute") {
    w.message(2, msg, ExecuteStreamReq);
  } else if (msg.type === "batch") {
    w.message(3, msg, BatchStreamReq);
  } else if (msg.type === "sequence") {
    w.message(4, msg, SequenceStreamReq);
  } else if (msg.type === "describe") {
    w.message(5, msg, DescribeStreamReq);
  } else if (msg.type === "store_sql") {
    w.message(6, msg, StoreSqlStreamReq);
  } else if (msg.type === "close_sql") {
    w.message(7, msg, CloseSqlStreamReq);
  } else if (msg.type === "get_autocommit") {
    w.message(8, msg, GetAutocommitStreamReq);
  } else {
    throw impossible(msg, "Impossible type of StreamRequest");
  }
}
function CloseStreamReq2(_w, _msg) {
}
function ExecuteStreamReq(w, msg) {
  w.message(1, msg.stmt, Stmt3);
}
function BatchStreamReq(w, msg) {
  w.message(1, msg.batch, Batch3);
}
function SequenceStreamReq(w, msg) {
  if (msg.sql !== void 0) {
    w.string(1, msg.sql);
  }
  if (msg.sqlId !== void 0) {
    w.int32(2, msg.sqlId);
  }
}
function DescribeStreamReq(w, msg) {
  if (msg.sql !== void 0) {
    w.string(1, msg.sql);
  }
  if (msg.sqlId !== void 0) {
    w.int32(2, msg.sqlId);
  }
}
function StoreSqlStreamReq(w, msg) {
  w.int32(1, msg.sqlId);
  w.string(2, msg.sql);
}
function CloseSqlStreamReq(w, msg) {
  w.int32(1, msg.sqlId);
}
function GetAutocommitStreamReq(_w, _msg) {
}
function CursorReqBody2(w, msg) {
  if (msg.baton !== void 0) {
    w.string(1, msg.baton);
  }
  w.message(2, msg.batch, Batch3);
}

// node_modules/@libsql/hrana-client/lib-esm/http/stream.js
var _client3, _baseUrl, _jwt, _fetch3, _baton, _queue3, _flushing, _cursor2, _closing2, _closeQueued, _closed6, _sqlIdAlloc2, _sendStreamRequest2, sendStreamRequest_fn2, _pushToQueue2, pushToQueue_fn2, _flushQueue2, flushQueue_fn2, _flushPipeline, flushPipeline_fn, _flushCursor, flushCursor_fn, _flush, flush_fn, _createPipelineRequest, createPipelineRequest_fn, _createCursorRequest, createCursorRequest_fn, _createRequest, createRequest_fn;
var HttpStream = class extends Stream {
  /** @private */
  constructor(client, baseUrl, jwt, customFetch) {
    super(client.intMode);
    __privateAdd(this, _sendStreamRequest2);
    __privateAdd(this, _pushToQueue2);
    __privateAdd(this, _flushQueue2);
    __privateAdd(this, _flushPipeline);
    __privateAdd(this, _flushCursor);
    __privateAdd(this, _flush);
    __privateAdd(this, _createPipelineRequest);
    __privateAdd(this, _createCursorRequest);
    __privateAdd(this, _createRequest);
    __privateAdd(this, _client3, void 0);
    __privateAdd(this, _baseUrl, void 0);
    __privateAdd(this, _jwt, void 0);
    __privateAdd(this, _fetch3, void 0);
    __privateAdd(this, _baton, void 0);
    __privateAdd(this, _queue3, void 0);
    __privateAdd(this, _flushing, void 0);
    __privateAdd(this, _cursor2, void 0);
    __privateAdd(this, _closing2, void 0);
    __privateAdd(this, _closeQueued, void 0);
    __privateAdd(this, _closed6, void 0);
    __privateAdd(this, _sqlIdAlloc2, void 0);
    __privateSet(this, _client3, client);
    __privateSet(this, _baseUrl, baseUrl.toString());
    __privateSet(this, _jwt, jwt);
    __privateSet(this, _fetch3, customFetch);
    __privateSet(this, _baton, void 0);
    __privateSet(this, _queue3, new Queue());
    __privateSet(this, _flushing, false);
    __privateSet(this, _closing2, false);
    __privateSet(this, _closeQueued, false);
    __privateSet(this, _closed6, void 0);
    __privateSet(this, _sqlIdAlloc2, new IdAlloc());
  }
  /** Get the {@link HttpClient} object that this stream belongs to. */
  client() {
    return __privateGet(this, _client3);
  }
  /** @private */
  _sqlOwner() {
    return this;
  }
  /** Cache a SQL text on the server. */
  storeSql(sql) {
    const sqlId = __privateGet(this, _sqlIdAlloc2).alloc();
    __privateMethod(this, _sendStreamRequest2, sendStreamRequest_fn2).call(this, { type: "store_sql", sqlId, sql }).then(() => void 0, (error) => this._setClosed(error));
    return new Sql(this, sqlId);
  }
  /** @private */
  _closeSql(sqlId) {
    if (__privateGet(this, _closed6) !== void 0) {
      return;
    }
    __privateMethod(this, _sendStreamRequest2, sendStreamRequest_fn2).call(this, { type: "close_sql", sqlId }).then(() => __privateGet(this, _sqlIdAlloc2).free(sqlId), (error) => this._setClosed(error));
  }
  /** @private */
  _execute(stmt) {
    return __privateMethod(this, _sendStreamRequest2, sendStreamRequest_fn2).call(this, { type: "execute", stmt }).then((response) => {
      return response.result;
    });
  }
  /** @private */
  _batch(batch) {
    return __privateMethod(this, _sendStreamRequest2, sendStreamRequest_fn2).call(this, { type: "batch", batch }).then((response) => {
      return response.result;
    });
  }
  /** @private */
  _describe(protoSql) {
    return __privateMethod(this, _sendStreamRequest2, sendStreamRequest_fn2).call(this, {
      type: "describe",
      sql: protoSql.sql,
      sqlId: protoSql.sqlId
    }).then((response) => {
      return response.result;
    });
  }
  /** @private */
  _sequence(protoSql) {
    return __privateMethod(this, _sendStreamRequest2, sendStreamRequest_fn2).call(this, {
      type: "sequence",
      sql: protoSql.sql,
      sqlId: protoSql.sqlId
    }).then((_response) => {
      return void 0;
    });
  }
  /** Check whether the SQL connection underlying this stream is in autocommit state (i.e., outside of an
   * explicit transaction). This requires protocol version 3 or higher.
   */
  getAutocommit() {
    __privateGet(this, _client3)._ensureVersion(3, "getAutocommit()");
    return __privateMethod(this, _sendStreamRequest2, sendStreamRequest_fn2).call(this, {
      type: "get_autocommit"
    }).then((response) => {
      return response.isAutocommit;
    });
  }
  /** @private */
  _openCursor(batch) {
    return new Promise((cursorCallback, errorCallback) => {
      __privateMethod(this, _pushToQueue2, pushToQueue_fn2).call(this, { type: "cursor", batch, cursorCallback, errorCallback });
    });
  }
  /** @private */
  _cursorClosed(cursor) {
    if (cursor !== __privateGet(this, _cursor2)) {
      throw new InternalError("Cursor was closed, but it was not associated with the stream");
    }
    __privateSet(this, _cursor2, void 0);
    _queueMicrotask(() => __privateMethod(this, _flushQueue2, flushQueue_fn2).call(this));
  }
  /** Immediately close the stream. */
  close() {
    this._setClosed(new ClientError("Stream was manually closed"));
  }
  /** Gracefully close the stream. */
  closeGracefully() {
    __privateSet(this, _closing2, true);
    _queueMicrotask(() => __privateMethod(this, _flushQueue2, flushQueue_fn2).call(this));
  }
  /** True if the stream is closed. */
  get closed() {
    return __privateGet(this, _closed6) !== void 0 || __privateGet(this, _closing2);
  }
  /** @private */
  _setClosed(error) {
    if (__privateGet(this, _closed6) !== void 0) {
      return;
    }
    __privateSet(this, _closed6, error);
    if (__privateGet(this, _cursor2) !== void 0) {
      __privateGet(this, _cursor2)._setClosed(error);
    }
    __privateGet(this, _client3)._streamClosed(this);
    for (; ; ) {
      const entry = __privateGet(this, _queue3).shift();
      if (entry !== void 0) {
        entry.errorCallback(error);
      } else {
        break;
      }
    }
    if ((__privateGet(this, _baton) !== void 0 || __privateGet(this, _flushing)) && !__privateGet(this, _closeQueued)) {
      __privateGet(this, _queue3).push({
        type: "pipeline",
        request: { type: "close" },
        responseCallback: () => void 0,
        errorCallback: () => void 0
      });
      __privateSet(this, _closeQueued, true);
      _queueMicrotask(() => __privateMethod(this, _flushQueue2, flushQueue_fn2).call(this));
    }
  }
};
_client3 = new WeakMap();
_baseUrl = new WeakMap();
_jwt = new WeakMap();
_fetch3 = new WeakMap();
_baton = new WeakMap();
_queue3 = new WeakMap();
_flushing = new WeakMap();
_cursor2 = new WeakMap();
_closing2 = new WeakMap();
_closeQueued = new WeakMap();
_closed6 = new WeakMap();
_sqlIdAlloc2 = new WeakMap();
_sendStreamRequest2 = new WeakSet();
sendStreamRequest_fn2 = function(request) {
  return new Promise((responseCallback, errorCallback) => {
    __privateMethod(this, _pushToQueue2, pushToQueue_fn2).call(this, { type: "pipeline", request, responseCallback, errorCallback });
  });
};
_pushToQueue2 = new WeakSet();
pushToQueue_fn2 = function(entry) {
  if (__privateGet(this, _closed6) !== void 0) {
    throw new ClosedError("Stream is closed", __privateGet(this, _closed6));
  } else if (__privateGet(this, _closing2)) {
    throw new ClosedError("Stream is closing", void 0);
  } else {
    __privateGet(this, _queue3).push(entry);
    _queueMicrotask(() => __privateMethod(this, _flushQueue2, flushQueue_fn2).call(this));
  }
};
_flushQueue2 = new WeakSet();
flushQueue_fn2 = function() {
  if (__privateGet(this, _flushing) || __privateGet(this, _cursor2) !== void 0) {
    return;
  }
  if (__privateGet(this, _closing2) && __privateGet(this, _queue3).length === 0) {
    this._setClosed(new ClientError("Stream was gracefully closed"));
    return;
  }
  const endpoint = __privateGet(this, _client3)._endpoint;
  if (endpoint === void 0) {
    __privateGet(this, _client3)._endpointPromise.then(() => __privateMethod(this, _flushQueue2, flushQueue_fn2).call(this), (error) => this._setClosed(error));
    return;
  }
  const firstEntry = __privateGet(this, _queue3).shift();
  if (firstEntry === void 0) {
    return;
  } else if (firstEntry.type === "pipeline") {
    const pipeline = [firstEntry];
    for (; ; ) {
      const entry = __privateGet(this, _queue3).first();
      if (entry !== void 0 && entry.type === "pipeline") {
        pipeline.push(entry);
        __privateGet(this, _queue3).shift();
      } else if (entry === void 0 && __privateGet(this, _closing2) && !__privateGet(this, _closeQueued)) {
        pipeline.push({
          type: "pipeline",
          request: { type: "close" },
          responseCallback: () => void 0,
          errorCallback: () => void 0
        });
        __privateSet(this, _closeQueued, true);
        break;
      } else {
        break;
      }
    }
    __privateMethod(this, _flushPipeline, flushPipeline_fn).call(this, endpoint, pipeline);
  } else if (firstEntry.type === "cursor") {
    __privateMethod(this, _flushCursor, flushCursor_fn).call(this, endpoint, firstEntry);
  } else {
    throw impossible(firstEntry, "Impossible type of QueueEntry");
  }
};
_flushPipeline = new WeakSet();
flushPipeline_fn = function(endpoint, pipeline) {
  __privateMethod(this, _flush, flush_fn).call(this, () => __privateMethod(this, _createPipelineRequest, createPipelineRequest_fn).call(this, pipeline, endpoint), (resp) => decodePipelineResponse(resp, endpoint.encoding), (respBody) => respBody.baton, (respBody) => respBody.baseUrl, (respBody) => handlePipelineResponse(pipeline, respBody), (error) => pipeline.forEach((entry) => entry.errorCallback(error)));
};
_flushCursor = new WeakSet();
flushCursor_fn = function(endpoint, entry) {
  const cursor = new HttpCursor(this, endpoint.encoding);
  __privateSet(this, _cursor2, cursor);
  __privateMethod(this, _flush, flush_fn).call(this, () => __privateMethod(this, _createCursorRequest, createCursorRequest_fn).call(this, entry, endpoint), (resp) => cursor.open(resp), (respBody) => respBody.baton, (respBody) => respBody.baseUrl, (_respBody) => entry.cursorCallback(cursor), (error) => entry.errorCallback(error));
};
_flush = new WeakSet();
flush_fn = function(createRequest, decodeResponse, getBaton, getBaseUrl, handleResponse, handleError) {
  let promise;
  try {
    const request = createRequest();
    const fetch2 = __privateGet(this, _fetch3);
    promise = fetch2(request);
  } catch (error) {
    promise = Promise.reject(error);
  }
  __privateSet(this, _flushing, true);
  promise.then((resp) => {
    if (!resp.ok) {
      return errorFromResponse(resp).then((error) => {
        throw error;
      });
    }
    return decodeResponse(resp);
  }).then((r) => {
    __privateSet(this, _baton, getBaton(r));
    __privateSet(this, _baseUrl, getBaseUrl(r) ?? __privateGet(this, _baseUrl));
    handleResponse(r);
  }).catch((error) => {
    this._setClosed(error);
    handleError(error);
  }).finally(() => {
    __privateSet(this, _flushing, false);
    __privateMethod(this, _flushQueue2, flushQueue_fn2).call(this);
  });
};
_createPipelineRequest = new WeakSet();
createPipelineRequest_fn = function(pipeline, endpoint) {
  return __privateMethod(this, _createRequest, createRequest_fn).call(this, new URL(endpoint.pipelinePath, __privateGet(this, _baseUrl)), {
    baton: __privateGet(this, _baton),
    requests: pipeline.map((entry) => entry.request)
  }, endpoint.encoding, PipelineReqBody, PipelineReqBody2);
};
_createCursorRequest = new WeakSet();
createCursorRequest_fn = function(entry, endpoint) {
  if (endpoint.cursorPath === void 0) {
    throw new ProtocolVersionError(`Cursors are supported only on protocol version 3 and higher, but the HTTP server only supports version ${endpoint.version}.`);
  }
  return __privateMethod(this, _createRequest, createRequest_fn).call(this, new URL(endpoint.cursorPath, __privateGet(this, _baseUrl)), {
    baton: __privateGet(this, _baton),
    batch: entry.batch
  }, endpoint.encoding, CursorReqBody, CursorReqBody2);
};
_createRequest = new WeakSet();
createRequest_fn = function(url, reqBody, encoding, jsonFun, protobufFun) {
  let bodyData;
  let contentType;
  if (encoding === "json") {
    bodyData = writeJsonObject(reqBody, jsonFun);
    contentType = "application/json";
  } else if (encoding === "protobuf") {
    bodyData = writeProtobufMessage(reqBody, protobufFun);
    contentType = "application/x-protobuf";
  } else {
    throw impossible(encoding, "Impossible encoding");
  }
  const headers = new _Headers();
  headers.set("content-type", contentType);
  if (__privateGet(this, _jwt) !== void 0) {
    headers.set("authorization", `Bearer ${__privateGet(this, _jwt)}`);
  }
  return new _Request(url.toString(), { method: "POST", headers, body: bodyData });
};
function handlePipelineResponse(pipeline, respBody) {
  if (respBody.results.length !== pipeline.length) {
    throw new ProtoError("Server returned unexpected number of pipeline results");
  }
  for (let i = 0; i < pipeline.length; ++i) {
    const result = respBody.results[i];
    const entry = pipeline[i];
    if (result.type === "ok") {
      if (result.response.type !== entry.request.type) {
        throw new ProtoError("Received unexpected type of response");
      }
      entry.responseCallback(result.response);
    } else if (result.type === "error") {
      entry.errorCallback(errorFromProto(result.error));
    } else if (result.type === "none") {
      throw new ProtoError("Received unrecognized type of StreamResult");
    } else {
      throw impossible(result, "Received impossible type of StreamResult");
    }
  }
}
async function decodePipelineResponse(resp, encoding) {
  var _a;
  if (encoding === "json") {
    const respJson = await resp.json();
    return readJsonObject(respJson, PipelineRespBody);
  }
  if (encoding === "protobuf") {
    const respData = await resp.arrayBuffer();
    return readProtobufMessage(new Uint8Array(respData), PipelineRespBody2);
  }
  await ((_a = resp.body) == null ? void 0 : _a.cancel());
  throw impossible(encoding, "Impossible encoding");
}
async function errorFromResponse(resp) {
  var _a;
  const respType = resp.headers.get("content-type") ?? "text/plain";
  let message = `Server returned HTTP status ${resp.status}`;
  if (respType === "application/json") {
    const respBody = await resp.json();
    if ("message" in respBody) {
      return errorFromProto(respBody);
    }
    return new HttpServerError(message, resp.status);
  }
  if (respType === "text/plain") {
    const respBody = (await resp.text()).trim();
    if (respBody !== "") {
      message += `: ${respBody}`;
    }
    return new HttpServerError(message, resp.status);
  }
  await ((_a = resp.body) == null ? void 0 : _a.cancel());
  return new HttpServerError(message, resp.status);
}

// node_modules/@libsql/hrana-client/lib-esm/http/client.js
var checkEndpoints = [
  {
    versionPath: "v3-protobuf",
    pipelinePath: "v3-protobuf/pipeline",
    cursorPath: "v3-protobuf/cursor",
    version: 3,
    encoding: "protobuf"
  }
  /*
  {
      versionPath: "v3",
      pipelinePath: "v3/pipeline",
      cursorPath: "v3/cursor",
      version: 3,
      encoding: "json",
  },
  */
];
var fallbackEndpoint = {
  versionPath: "v2",
  pipelinePath: "v2/pipeline",
  cursorPath: void 0,
  version: 2,
  encoding: "json"
};
var _url, _jwt2, _fetch4, _closed7, _streams, _setClosed3, setClosed_fn3;
var HttpClient = class extends Client {
  /** @private */
  constructor(url, jwt, customFetch, protocolVersion = 2) {
    super();
    __privateAdd(this, _setClosed3);
    __privateAdd(this, _url, void 0);
    __privateAdd(this, _jwt2, void 0);
    __privateAdd(this, _fetch4, void 0);
    __privateAdd(this, _closed7, void 0);
    __privateAdd(this, _streams, void 0);
    /** @private */
    __publicField(this, "_endpointPromise");
    /** @private */
    __publicField(this, "_endpoint");
    __privateSet(this, _url, url);
    __privateSet(this, _jwt2, jwt);
    __privateSet(this, _fetch4, customFetch ?? _fetch2);
    __privateSet(this, _closed7, void 0);
    __privateSet(this, _streams, /* @__PURE__ */ new Set());
    if (protocolVersion == 3) {
      this._endpointPromise = findEndpoint(__privateGet(this, _fetch4), __privateGet(this, _url));
      this._endpointPromise.then((endpoint) => this._endpoint = endpoint, (error) => __privateMethod(this, _setClosed3, setClosed_fn3).call(this, error));
    } else {
      this._endpointPromise = Promise.resolve(fallbackEndpoint);
      this._endpointPromise.then((endpoint) => this._endpoint = endpoint, (error) => __privateMethod(this, _setClosed3, setClosed_fn3).call(this, error));
    }
  }
  /** Get the protocol version supported by the server. */
  async getVersion() {
    if (this._endpoint !== void 0) {
      return this._endpoint.version;
    }
    return (await this._endpointPromise).version;
  }
  // Make sure that the negotiated version is at least `minVersion`.
  /** @private */
  _ensureVersion(minVersion, feature) {
    if (minVersion <= fallbackEndpoint.version) {
      return;
    } else if (this._endpoint === void 0) {
      throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, but the version supported by the HTTP server is not yet known. Use Client.getVersion() to wait until the version is available.`);
    } else if (this._endpoint.version < minVersion) {
      throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, but the HTTP server only supports version ${this._endpoint.version}.`);
    }
  }
  /** Open a {@link HttpStream}, a stream for executing SQL statements. */
  openStream() {
    if (__privateGet(this, _closed7) !== void 0) {
      throw new ClosedError("Client is closed", __privateGet(this, _closed7));
    }
    const stream = new HttpStream(this, __privateGet(this, _url), __privateGet(this, _jwt2), __privateGet(this, _fetch4));
    __privateGet(this, _streams).add(stream);
    return stream;
  }
  /** @private */
  _streamClosed(stream) {
    __privateGet(this, _streams).delete(stream);
  }
  /** Close the client and all its streams. */
  close() {
    __privateMethod(this, _setClosed3, setClosed_fn3).call(this, new ClientError("Client was manually closed"));
  }
  /** True if the client is closed. */
  get closed() {
    return __privateGet(this, _closed7) !== void 0;
  }
};
_url = new WeakMap();
_jwt2 = new WeakMap();
_fetch4 = new WeakMap();
_closed7 = new WeakMap();
_streams = new WeakMap();
_setClosed3 = new WeakSet();
setClosed_fn3 = function(error) {
  if (__privateGet(this, _closed7) !== void 0) {
    return;
  }
  __privateSet(this, _closed7, error);
  for (const stream of Array.from(__privateGet(this, _streams))) {
    stream._setClosed(new ClosedError("Client was closed", error));
  }
};
async function findEndpoint(customFetch, clientUrl) {
  const fetch2 = customFetch;
  for (const endpoint of checkEndpoints) {
    const url = new URL(endpoint.versionPath, clientUrl);
    const request = new _Request(url.toString(), { method: "GET" });
    const response = await fetch2(request);
    await response.arrayBuffer();
    if (response.ok) {
      return endpoint;
    }
  }
  return fallbackEndpoint;
}

// node_modules/@libsql/hrana-client/lib-esm/index.js
function openWs(url, jwt, protocolVersion = 2) {
  if (typeof _WebSocket === "undefined") {
    throw new WebSocketUnsupportedError("WebSockets are not supported in this environment");
  }
  var subprotocols = void 0;
  if (protocolVersion == 3) {
    subprotocols = Array.from(subprotocolsV3.keys());
  } else {
    subprotocols = Array.from(subprotocolsV2.keys());
  }
  const socket = new _WebSocket(url, subprotocols);
  return new WsClient(socket, jwt);
}
function openHttp(url, jwt, customFetch, protocolVersion = 2) {
  return new HttpClient(url instanceof URL ? url : new URL(url), jwt, customFetch, protocolVersion);
}

// node_modules/@libsql/client/lib-esm/hrana.js
var _mode, _version, _started;
var HranaTransaction = class {
  /** @private */
  constructor(mode, version2) {
    __privateAdd(this, _mode, void 0);
    __privateAdd(this, _version, void 0);
    // Promise that is resolved when the BEGIN statement completes, or `undefined` if we haven't executed the
    // BEGIN statement yet.
    __privateAdd(this, _started, void 0);
    __privateSet(this, _mode, mode);
    __privateSet(this, _version, version2);
    __privateSet(this, _started, void 0);
  }
  execute(stmt) {
    return this.batch([stmt]).then((results) => results[0]);
  }
  async batch(stmts) {
    const stream = this._getStream();
    if (stream.closed) {
      throw new LibsqlError("Cannot execute statements because the transaction is closed", "TRANSACTION_CLOSED");
    }
    try {
      const hranaStmts = stmts.map(stmtToHrana);
      let rowsPromises;
      if (__privateGet(this, _started) === void 0) {
        this._getSqlCache().apply(hranaStmts);
        const batch = stream.batch(__privateGet(this, _version) >= 3);
        const beginStep = batch.step();
        const beginPromise = beginStep.run(transactionModeToBegin(__privateGet(this, _mode)));
        let lastStep = beginStep;
        rowsPromises = hranaStmts.map((hranaStmt) => {
          const stmtStep = batch.step().condition(BatchCond.ok(lastStep));
          if (__privateGet(this, _version) >= 3) {
            stmtStep.condition(BatchCond.not(BatchCond.isAutocommit(batch)));
          }
          const rowsPromise = stmtStep.query(hranaStmt);
          rowsPromise.catch(() => void 0);
          lastStep = stmtStep;
          return rowsPromise;
        });
        __privateSet(this, _started, batch.execute().then(() => beginPromise).then(() => void 0));
        try {
          await __privateGet(this, _started);
        } catch (e) {
          this.close();
          throw e;
        }
      } else {
        if (__privateGet(this, _version) < 3) {
          await __privateGet(this, _started);
        } else {
        }
        this._getSqlCache().apply(hranaStmts);
        const batch = stream.batch(__privateGet(this, _version) >= 3);
        let lastStep = void 0;
        rowsPromises = hranaStmts.map((hranaStmt) => {
          const stmtStep = batch.step();
          if (lastStep !== void 0) {
            stmtStep.condition(BatchCond.ok(lastStep));
          }
          if (__privateGet(this, _version) >= 3) {
            stmtStep.condition(BatchCond.not(BatchCond.isAutocommit(batch)));
          }
          const rowsPromise = stmtStep.query(hranaStmt);
          rowsPromise.catch(() => void 0);
          lastStep = stmtStep;
          return rowsPromise;
        });
        await batch.execute();
      }
      const resultSets = [];
      for (const rowsPromise of rowsPromises) {
        const rows = await rowsPromise;
        if (rows === void 0) {
          throw new LibsqlError("Statement in a transaction was not executed, probably because the transaction has been rolled back", "TRANSACTION_CLOSED");
        }
        resultSets.push(resultSetFromHrana(rows));
      }
      return resultSets;
    } catch (e) {
      throw mapHranaError(e);
    }
  }
  async executeMultiple(sql) {
    const stream = this._getStream();
    if (stream.closed) {
      throw new LibsqlError("Cannot execute statements because the transaction is closed", "TRANSACTION_CLOSED");
    }
    try {
      if (__privateGet(this, _started) === void 0) {
        __privateSet(this, _started, stream.run(transactionModeToBegin(__privateGet(this, _mode))).then(() => void 0));
        try {
          await __privateGet(this, _started);
        } catch (e) {
          this.close();
          throw e;
        }
      } else {
        await __privateGet(this, _started);
      }
      await stream.sequence(sql);
    } catch (e) {
      throw mapHranaError(e);
    }
  }
  async rollback() {
    try {
      const stream = this._getStream();
      if (stream.closed) {
        return;
      }
      if (__privateGet(this, _started) !== void 0) {
      } else {
        return;
      }
      const promise = stream.run("ROLLBACK").catch((e) => {
        throw mapHranaError(e);
      });
      stream.closeGracefully();
      await promise;
    } catch (e) {
      throw mapHranaError(e);
    } finally {
      this.close();
    }
  }
  async commit() {
    try {
      const stream = this._getStream();
      if (stream.closed) {
        throw new LibsqlError("Cannot commit the transaction because it is already closed", "TRANSACTION_CLOSED");
      }
      if (__privateGet(this, _started) !== void 0) {
        await __privateGet(this, _started);
      } else {
        return;
      }
      const promise = stream.run("COMMIT").catch((e) => {
        throw mapHranaError(e);
      });
      stream.closeGracefully();
      await promise;
    } catch (e) {
      throw mapHranaError(e);
    } finally {
      this.close();
    }
  }
};
_mode = new WeakMap();
_version = new WeakMap();
_started = new WeakMap();
async function executeHranaBatch(mode, version2, batch, hranaStmts, disableForeignKeys = false) {
  if (disableForeignKeys) {
    batch.step().run("PRAGMA foreign_keys=off");
  }
  const beginStep = batch.step();
  const beginPromise = beginStep.run(transactionModeToBegin(mode));
  let lastStep = beginStep;
  const stmtPromises = hranaStmts.map((hranaStmt) => {
    const stmtStep = batch.step().condition(BatchCond.ok(lastStep));
    if (version2 >= 3) {
      stmtStep.condition(BatchCond.not(BatchCond.isAutocommit(batch)));
    }
    const stmtPromise = stmtStep.query(hranaStmt);
    lastStep = stmtStep;
    return stmtPromise;
  });
  const commitStep = batch.step().condition(BatchCond.ok(lastStep));
  if (version2 >= 3) {
    commitStep.condition(BatchCond.not(BatchCond.isAutocommit(batch)));
  }
  const commitPromise = commitStep.run("COMMIT");
  const rollbackStep = batch.step().condition(BatchCond.not(BatchCond.ok(commitStep)));
  rollbackStep.run("ROLLBACK").catch((_) => void 0);
  if (disableForeignKeys) {
    batch.step().run("PRAGMA foreign_keys=on");
  }
  await batch.execute();
  const resultSets = [];
  await beginPromise;
  for (const stmtPromise of stmtPromises) {
    const hranaRows = await stmtPromise;
    if (hranaRows === void 0) {
      throw new LibsqlError("Statement in a batch was not executed, probably because the transaction has been rolled back", "TRANSACTION_CLOSED");
    }
    resultSets.push(resultSetFromHrana(hranaRows));
  }
  await commitPromise;
  return resultSets;
}
function stmtToHrana(stmt) {
  let sql;
  let args;
  if (Array.isArray(stmt)) {
    [sql, args] = stmt;
  } else if (typeof stmt === "string") {
    sql = stmt;
  } else {
    sql = stmt.sql;
    args = stmt.args;
  }
  const hranaStmt = new Stmt(sql);
  if (args) {
    if (Array.isArray(args)) {
      hranaStmt.bindIndexes(args);
    } else {
      for (const [key, value] of Object.entries(args)) {
        hranaStmt.bindName(key, value);
      }
    }
  }
  return hranaStmt;
}
function resultSetFromHrana(hranaRows) {
  const columns = hranaRows.columnNames.map((c) => c ?? "");
  const columnTypes = hranaRows.columnDecltypes.map((c) => c ?? "");
  const rows = hranaRows.rows;
  const rowsAffected = hranaRows.affectedRowCount;
  const lastInsertRowid = hranaRows.lastInsertRowid !== void 0 ? hranaRows.lastInsertRowid : void 0;
  return new ResultSetImpl(columns, columnTypes, rows, rowsAffected, lastInsertRowid);
}
function mapHranaError(e) {
  if (e instanceof ClientError) {
    const code = mapHranaErrorCode(e);
    return new LibsqlError(e.message, code, void 0, e);
  }
  return e;
}
function mapHranaErrorCode(e) {
  if (e instanceof ResponseError && e.code !== void 0) {
    return e.code;
  } else if (e instanceof ProtoError) {
    return "HRANA_PROTO_ERROR";
  } else if (e instanceof ClosedError) {
    return e.cause instanceof ClientError ? mapHranaErrorCode(e.cause) : "HRANA_CLOSED_ERROR";
  } else if (e instanceof WebSocketError) {
    return "HRANA_WEBSOCKET_ERROR";
  } else if (e instanceof HttpServerError) {
    return "SERVER_ERROR";
  } else if (e instanceof ProtocolVersionError) {
    return "PROTOCOL_VERSION_ERROR";
  } else if (e instanceof InternalError) {
    return "INTERNAL_ERROR";
  } else {
    return "UNKNOWN";
  }
}

// node_modules/@libsql/client/lib-esm/sql_cache.js
var _owner2, _sqls;
var SqlCache = class {
  constructor(owner, capacity) {
    __privateAdd(this, _owner2, void 0);
    __privateAdd(this, _sqls, void 0);
    __publicField(this, "capacity");
    __privateSet(this, _owner2, owner);
    __privateSet(this, _sqls, new Lru());
    this.capacity = capacity;
  }
  // Replaces SQL strings with cached `hrana.Sql` objects in the statements in `hranaStmts`. After this
  // function returns, we guarantee that all `hranaStmts` refer to valid (not closed) `hrana.Sql` objects,
  // but _we may invalidate any other `hrana.Sql` objects_ (by closing them, thus removing them from the
  // server).
  //
  // In practice, this means that after calling this function, you can use the statements only up to the
  // first `await`, because concurrent code may also use the cache and invalidate those statements.
  apply(hranaStmts) {
    if (this.capacity <= 0) {
      return;
    }
    const usedSqlObjs = /* @__PURE__ */ new Set();
    for (const hranaStmt of hranaStmts) {
      if (typeof hranaStmt.sql !== "string") {
        continue;
      }
      const sqlText = hranaStmt.sql;
      if (sqlText.length >= 5e3) {
        continue;
      }
      let sqlObj = __privateGet(this, _sqls).get(sqlText);
      if (sqlObj === void 0) {
        while (__privateGet(this, _sqls).size + 1 > this.capacity) {
          const [evictSqlText, evictSqlObj] = __privateGet(this, _sqls).peekLru();
          if (usedSqlObjs.has(evictSqlObj)) {
            break;
          }
          evictSqlObj.close();
          __privateGet(this, _sqls).delete(evictSqlText);
        }
        if (__privateGet(this, _sqls).size + 1 <= this.capacity) {
          sqlObj = __privateGet(this, _owner2).storeSql(sqlText);
          __privateGet(this, _sqls).set(sqlText, sqlObj);
        }
      }
      if (sqlObj !== void 0) {
        hranaStmt.sql = sqlObj;
        usedSqlObjs.add(sqlObj);
      }
    }
  }
};
_owner2 = new WeakMap();
_sqls = new WeakMap();
var _cache;
var Lru = class {
  constructor() {
    // This maps keys to the cache values. The entries are ordered by their last use (entires that were used
    // most recently are at the end).
    __privateAdd(this, _cache, void 0);
    __privateSet(this, _cache, /* @__PURE__ */ new Map());
  }
  get(key) {
    const value = __privateGet(this, _cache).get(key);
    if (value !== void 0) {
      __privateGet(this, _cache).delete(key);
      __privateGet(this, _cache).set(key, value);
    }
    return value;
  }
  set(key, value) {
    __privateGet(this, _cache).set(key, value);
  }
  peekLru() {
    for (const entry of __privateGet(this, _cache).entries()) {
      return entry;
    }
    return void 0;
  }
  delete(key) {
    __privateGet(this, _cache).delete(key);
  }
  get size() {
    return __privateGet(this, _cache).size;
  }
};
_cache = new WeakMap();

// node_modules/@libsql/client/lib-esm/ws.js
var import_promise_limit = __toESM(require_promise_limit(), 1);
function _createClient(config) {
  if (config.scheme !== "wss" && config.scheme !== "ws") {
    throw new LibsqlError(`The WebSocket client supports only "libsql:", "wss:" and "ws:" URLs, got ${JSON.stringify(config.scheme + ":")}. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  if (config.encryptionKey !== void 0) {
    throw new LibsqlError("Encryption key is not supported by the remote client.", "ENCRYPTION_KEY_NOT_SUPPORTED");
  }
  if (config.scheme === "ws" && config.tls) {
    throw new LibsqlError(`A "ws:" URL cannot opt into TLS by using ?tls=1`, "URL_INVALID");
  } else if (config.scheme === "wss" && !config.tls) {
    throw new LibsqlError(`A "wss:" URL cannot opt out of TLS by using ?tls=0`, "URL_INVALID");
  }
  const url = encodeBaseUrl(config.scheme, config.authority, config.path);
  let client;
  try {
    client = openWs(url, config.authToken);
  } catch (e) {
    if (e instanceof WebSocketUnsupportedError) {
      const suggestedScheme = config.scheme === "wss" ? "https" : "http";
      const suggestedUrl = encodeBaseUrl(suggestedScheme, config.authority, config.path);
      throw new LibsqlError(`This environment does not support WebSockets, please switch to the HTTP client by using a "${suggestedScheme}:" URL (${JSON.stringify(suggestedUrl)}). For more information, please read ${supportedUrlLink}`, "WEBSOCKETS_NOT_SUPPORTED");
    }
    throw mapHranaError(e);
  }
  return new WsClient2(client, url, config.authToken, config.intMode, config.concurrency);
}
var maxConnAgeMillis = 60 * 1e3;
var sqlCacheCapacity = 100;
var _url2, _authToken, _intMode, _connState, _futureConnState, _isSchemaDatabase, _promiseLimitFunction, _openStream, openStream_fn, _openConn, openConn_fn;
var WsClient2 = class {
  /** @private */
  constructor(client, url, authToken, intMode, concurrency) {
    __privateAdd(this, _openStream);
    __privateAdd(this, _openConn);
    __privateAdd(this, _url2, void 0);
    __privateAdd(this, _authToken, void 0);
    __privateAdd(this, _intMode, void 0);
    // State of the current connection. The `hrana.WsClient` inside may be closed at any moment due to an
    // asynchronous error.
    __privateAdd(this, _connState, void 0);
    // If defined, this is a connection that will be used in the future, once it is ready.
    __privateAdd(this, _futureConnState, void 0);
    __publicField(this, "closed");
    __publicField(this, "protocol");
    __privateAdd(this, _isSchemaDatabase, void 0);
    __privateAdd(this, _promiseLimitFunction, void 0);
    __privateSet(this, _url2, url);
    __privateSet(this, _authToken, authToken);
    __privateSet(this, _intMode, intMode);
    __privateSet(this, _connState, __privateMethod(this, _openConn, openConn_fn).call(this, client));
    __privateSet(this, _futureConnState, void 0);
    this.closed = false;
    this.protocol = "ws";
    __privateSet(this, _promiseLimitFunction, (0, import_promise_limit.default)(concurrency));
  }
  async limit(fn) {
    return __privateGet(this, _promiseLimitFunction).call(this, fn);
  }
  async execute(stmtOrSql, args) {
    let stmt;
    if (typeof stmtOrSql === "string") {
      stmt = {
        sql: stmtOrSql,
        args: args || []
      };
    } else {
      stmt = stmtOrSql;
    }
    return this.limit(async () => {
      const streamState = await __privateMethod(this, _openStream, openStream_fn).call(this);
      try {
        const hranaStmt = stmtToHrana(stmt);
        streamState.conn.sqlCache.apply([hranaStmt]);
        const hranaRowsPromise = streamState.stream.query(hranaStmt);
        streamState.stream.closeGracefully();
        const hranaRowsResult = await hranaRowsPromise;
        return resultSetFromHrana(hranaRowsResult);
      } catch (e) {
        throw mapHranaError(e);
      } finally {
        this._closeStream(streamState);
      }
    });
  }
  async batch(stmts, mode = "deferred") {
    return this.limit(async () => {
      const streamState = await __privateMethod(this, _openStream, openStream_fn).call(this);
      try {
        const normalizedStmts = stmts.map((stmt) => {
          if (Array.isArray(stmt)) {
            return {
              sql: stmt[0],
              args: stmt[1] || []
            };
          }
          return stmt;
        });
        const hranaStmts = normalizedStmts.map(stmtToHrana);
        const version2 = await streamState.conn.client.getVersion();
        streamState.conn.sqlCache.apply(hranaStmts);
        const batch = streamState.stream.batch(version2 >= 3);
        const resultsPromise = executeHranaBatch(mode, version2, batch, hranaStmts);
        const results = await resultsPromise;
        return results;
      } catch (e) {
        throw mapHranaError(e);
      } finally {
        this._closeStream(streamState);
      }
    });
  }
  async migrate(stmts) {
    return this.limit(async () => {
      const streamState = await __privateMethod(this, _openStream, openStream_fn).call(this);
      try {
        const hranaStmts = stmts.map(stmtToHrana);
        const version2 = await streamState.conn.client.getVersion();
        const batch = streamState.stream.batch(version2 >= 3);
        const resultsPromise = executeHranaBatch("deferred", version2, batch, hranaStmts, true);
        const results = await resultsPromise;
        return results;
      } catch (e) {
        throw mapHranaError(e);
      } finally {
        this._closeStream(streamState);
      }
    });
  }
  async transaction(mode = "write") {
    return this.limit(async () => {
      const streamState = await __privateMethod(this, _openStream, openStream_fn).call(this);
      try {
        const version2 = await streamState.conn.client.getVersion();
        return new WsTransaction(this, streamState, mode, version2);
      } catch (e) {
        this._closeStream(streamState);
        throw mapHranaError(e);
      }
    });
  }
  async executeMultiple(sql) {
    return this.limit(async () => {
      const streamState = await __privateMethod(this, _openStream, openStream_fn).call(this);
      try {
        const promise = streamState.stream.sequence(sql);
        streamState.stream.closeGracefully();
        await promise;
      } catch (e) {
        throw mapHranaError(e);
      } finally {
        this._closeStream(streamState);
      }
    });
  }
  sync() {
    throw new LibsqlError("sync not supported in ws mode", "SYNC_NOT_SUPPORTED");
  }
  _closeStream(streamState) {
    streamState.stream.close();
    const connState = streamState.conn;
    connState.streamStates.delete(streamState);
    if (connState.streamStates.size === 0 && connState !== __privateGet(this, _connState)) {
      connState.client.close();
    }
  }
  close() {
    __privateGet(this, _connState).client.close();
    this.closed = true;
  }
};
_url2 = new WeakMap();
_authToken = new WeakMap();
_intMode = new WeakMap();
_connState = new WeakMap();
_futureConnState = new WeakMap();
_isSchemaDatabase = new WeakMap();
_promiseLimitFunction = new WeakMap();
_openStream = new WeakSet();
openStream_fn = async function() {
  if (this.closed) {
    throw new LibsqlError("The client is closed", "CLIENT_CLOSED");
  }
  const now = /* @__PURE__ */ new Date();
  const ageMillis = now.valueOf() - __privateGet(this, _connState).openTime.valueOf();
  if (ageMillis > maxConnAgeMillis && __privateGet(this, _futureConnState) === void 0) {
    const futureConnState = __privateMethod(this, _openConn, openConn_fn).call(this);
    __privateSet(this, _futureConnState, futureConnState);
    futureConnState.client.getVersion().then((_version2) => {
      if (__privateGet(this, _connState) !== futureConnState) {
        if (__privateGet(this, _connState).streamStates.size === 0) {
          __privateGet(this, _connState).client.close();
        } else {
        }
      }
      __privateSet(this, _connState, futureConnState);
      __privateSet(this, _futureConnState, void 0);
    }, (_e) => {
      __privateSet(this, _futureConnState, void 0);
    });
  }
  if (__privateGet(this, _connState).client.closed) {
    try {
      if (__privateGet(this, _futureConnState) !== void 0) {
        __privateSet(this, _connState, __privateGet(this, _futureConnState));
      } else {
        __privateSet(this, _connState, __privateMethod(this, _openConn, openConn_fn).call(this));
      }
    } catch (e) {
      throw mapHranaError(e);
    }
  }
  const connState = __privateGet(this, _connState);
  try {
    if (connState.useSqlCache === void 0) {
      connState.useSqlCache = await connState.client.getVersion() >= 2;
      if (connState.useSqlCache) {
        connState.sqlCache.capacity = sqlCacheCapacity;
      }
    }
    const stream = connState.client.openStream();
    stream.intMode = __privateGet(this, _intMode);
    const streamState = { conn: connState, stream };
    connState.streamStates.add(streamState);
    return streamState;
  } catch (e) {
    throw mapHranaError(e);
  }
};
_openConn = new WeakSet();
openConn_fn = function(client) {
  try {
    client ?? (client = openWs(__privateGet(this, _url2), __privateGet(this, _authToken)));
    return {
      client,
      useSqlCache: void 0,
      sqlCache: new SqlCache(client, 0),
      openTime: /* @__PURE__ */ new Date(),
      streamStates: /* @__PURE__ */ new Set()
    };
  } catch (e) {
    throw mapHranaError(e);
  }
};
var _client4, _streamState;
var WsTransaction = class extends HranaTransaction {
  /** @private */
  constructor(client, state, mode, version2) {
    super(mode, version2);
    __privateAdd(this, _client4, void 0);
    __privateAdd(this, _streamState, void 0);
    __privateSet(this, _client4, client);
    __privateSet(this, _streamState, state);
  }
  /** @private */
  _getStream() {
    return __privateGet(this, _streamState).stream;
  }
  /** @private */
  _getSqlCache() {
    return __privateGet(this, _streamState).conn.sqlCache;
  }
  close() {
    __privateGet(this, _client4)._closeStream(__privateGet(this, _streamState));
  }
  get closed() {
    return __privateGet(this, _streamState).stream.closed;
  }
};
_client4 = new WeakMap();
_streamState = new WeakMap();

// node_modules/@libsql/client/lib-esm/http.js
var import_promise_limit2 = __toESM(require_promise_limit(), 1);
function _createClient2(config) {
  if (config.scheme !== "https" && config.scheme !== "http") {
    throw new LibsqlError(`The HTTP client supports only "libsql:", "https:" and "http:" URLs, got ${JSON.stringify(config.scheme + ":")}. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  if (config.encryptionKey !== void 0) {
    throw new LibsqlError("Encryption key is not supported by the remote client.", "ENCRYPTION_KEY_NOT_SUPPORTED");
  }
  if (config.scheme === "http" && config.tls) {
    throw new LibsqlError(`A "http:" URL cannot opt into TLS by using ?tls=1`, "URL_INVALID");
  } else if (config.scheme === "https" && !config.tls) {
    throw new LibsqlError(`A "https:" URL cannot opt out of TLS by using ?tls=0`, "URL_INVALID");
  }
  const url = encodeBaseUrl(config.scheme, config.authority, config.path);
  return new HttpClient2(url, config.authToken, config.intMode, config.fetch, config.concurrency);
}
var sqlCacheCapacity2 = 30;
var _client5, _authToken2, _promiseLimitFunction2;
var HttpClient2 = class {
  /** @private */
  constructor(url, authToken, intMode, customFetch, concurrency) {
    __privateAdd(this, _client5, void 0);
    __publicField(this, "protocol");
    __privateAdd(this, _authToken2, void 0);
    __privateAdd(this, _promiseLimitFunction2, void 0);
    __privateSet(this, _client5, openHttp(url, authToken, customFetch));
    __privateGet(this, _client5).intMode = intMode;
    this.protocol = "http";
    __privateSet(this, _authToken2, authToken);
    __privateSet(this, _promiseLimitFunction2, (0, import_promise_limit2.default)(concurrency));
  }
  async limit(fn) {
    return __privateGet(this, _promiseLimitFunction2).call(this, fn);
  }
  async execute(stmtOrSql, args) {
    let stmt;
    if (typeof stmtOrSql === "string") {
      stmt = {
        sql: stmtOrSql,
        args: args || []
      };
    } else {
      stmt = stmtOrSql;
    }
    return this.limit(async () => {
      try {
        const hranaStmt = stmtToHrana(stmt);
        let rowsPromise;
        const stream = __privateGet(this, _client5).openStream();
        try {
          rowsPromise = stream.query(hranaStmt);
        } finally {
          stream.closeGracefully();
        }
        const rowsResult = await rowsPromise;
        return resultSetFromHrana(rowsResult);
      } catch (e) {
        throw mapHranaError(e);
      }
    });
  }
  async batch(stmts, mode = "deferred") {
    return this.limit(async () => {
      try {
        const normalizedStmts = stmts.map((stmt) => {
          if (Array.isArray(stmt)) {
            return {
              sql: stmt[0],
              args: stmt[1] || []
            };
          }
          return stmt;
        });
        const hranaStmts = normalizedStmts.map(stmtToHrana);
        const version2 = await __privateGet(this, _client5).getVersion();
        let resultsPromise;
        const stream = __privateGet(this, _client5).openStream();
        try {
          const sqlCache = new SqlCache(stream, sqlCacheCapacity2);
          sqlCache.apply(hranaStmts);
          const batch = stream.batch(false);
          resultsPromise = executeHranaBatch(mode, version2, batch, hranaStmts);
        } finally {
          stream.closeGracefully();
        }
        const results = await resultsPromise;
        return results;
      } catch (e) {
        throw mapHranaError(e);
      }
    });
  }
  async migrate(stmts) {
    return this.limit(async () => {
      try {
        const hranaStmts = stmts.map(stmtToHrana);
        const version2 = await __privateGet(this, _client5).getVersion();
        let resultsPromise;
        const stream = __privateGet(this, _client5).openStream();
        try {
          const batch = stream.batch(false);
          resultsPromise = executeHranaBatch("deferred", version2, batch, hranaStmts, true);
        } finally {
          stream.closeGracefully();
        }
        const results = await resultsPromise;
        return results;
      } catch (e) {
        throw mapHranaError(e);
      }
    });
  }
  async transaction(mode = "write") {
    return this.limit(async () => {
      try {
        const version2 = await __privateGet(this, _client5).getVersion();
        return new HttpTransaction(__privateGet(this, _client5).openStream(), mode, version2);
      } catch (e) {
        throw mapHranaError(e);
      }
    });
  }
  async executeMultiple(sql) {
    return this.limit(async () => {
      try {
        let promise;
        const stream = __privateGet(this, _client5).openStream();
        try {
          promise = stream.sequence(sql);
        } finally {
          stream.closeGracefully();
        }
        await promise;
      } catch (e) {
        throw mapHranaError(e);
      }
    });
  }
  sync() {
    throw new LibsqlError("sync not supported in http mode", "SYNC_NOT_SUPPORTED");
  }
  close() {
    __privateGet(this, _client5).close();
  }
  get closed() {
    return __privateGet(this, _client5).closed;
  }
};
_client5 = new WeakMap();
_authToken2 = new WeakMap();
_promiseLimitFunction2 = new WeakMap();
var _stream3, _sqlCache;
var HttpTransaction = class extends HranaTransaction {
  /** @private */
  constructor(stream, mode, version2) {
    super(mode, version2);
    __privateAdd(this, _stream3, void 0);
    __privateAdd(this, _sqlCache, void 0);
    __privateSet(this, _stream3, stream);
    __privateSet(this, _sqlCache, new SqlCache(stream, sqlCacheCapacity2));
  }
  /** @private */
  _getStream() {
    return __privateGet(this, _stream3);
  }
  /** @private */
  _getSqlCache() {
    return __privateGet(this, _sqlCache);
  }
  close() {
    __privateGet(this, _stream3).close();
  }
  get closed() {
    return __privateGet(this, _stream3).closed;
  }
};
_stream3 = new WeakMap();
_sqlCache = new WeakMap();

// node_modules/@libsql/client/lib-esm/web.js
function createClient(config) {
  return _createClient3(expandConfig(config, true));
}
function _createClient3(config) {
  if (config.scheme === "ws" || config.scheme === "wss") {
    return _createClient(config);
  } else if (config.scheme === "http" || config.scheme === "https") {
    return _createClient2(config);
  } else {
    throw new LibsqlError(`The client that uses Web standard APIs supports only "libsql:", "wss:", "ws:", "https:" and "http:" URLs, got ${JSON.stringify(config.scheme + ":")}. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
}
export {
  LibsqlError,
  _createClient3 as _createClient,
  createClient
};
//# sourceMappingURL=@libsql_client.js.map
